
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Logic &#8212; SymPy 1.10.dev documentation</title>
    
    <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
  
    
    <link rel="stylesheet"
      href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
    <link rel="preload" as="font" type="font/woff2" crossorigin
      href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
    <link rel="preload" as="font" type="font/woff2" crossorigin
      href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">
  
    
      
  
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/pydata-sphinx-theme.css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    
    <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">
  
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <link rel="shortcut icon" href="../_static/sympy-notailtext-favicon.ico"/>
    <link href="https://docs.sympy.org/latest/modules/logic.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Sets" href="sets.html" />
    <link rel="prev" title="Logic" href="../reference/public/logic/index.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="../index.html">
  <img src="../_static/sympylogo.png" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../tutorial/index.html">
  SymPy Tutorial
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../guides/index.html">
  SymPy Guides
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../explanation/index.html">
  Explanation
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="../reference/index.html">
  Reference Documentation
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../miscellaneous/index.html">
  Miscellaneous
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../reference/public/basics/index.html">
   Basics
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="assumptions/index.html">
     Assumptions
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
    <label for="toctree-checkbox-2">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="assumptions/ask.html">
       Ask
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="assumptions/assume.html">
       Assume
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="assumptions/refine.html">
       Refine
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="assumptions/predicates.html">
       Predicates
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="calculus/index.html">
     Calculus
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="combinatorics/index.html">
     Combinatorics
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
    <label for="toctree-checkbox-3">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="combinatorics/partitions.html">
       Partitions
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="combinatorics/permutations.html">
       Permutations
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="combinatorics/perm_groups.html">
       Permutation Groups
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="combinatorics/polyhedron.html">
       Polyhedron
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="combinatorics/prufer.html">
       Prufer Sequences
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="combinatorics/subsets.html">
       Subsets
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="combinatorics/graycode.html">
       Gray Code
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="combinatorics/named_groups.html">
       Named Groups
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="combinatorics/util.html">
       Utilities
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="combinatorics/group_constructs.html">
       Group constructors
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="combinatorics/testutil.html">
       Test Utilities
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="combinatorics/tensor_can.html">
       Tensor Canonicalization
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="combinatorics/fp_groups.html">
       Finitely Presented Groups
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="combinatorics/pc_groups.html">
       Polycyclic Groups
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="functions/index.html">
     Functions
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
    <label for="toctree-checkbox-4">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="functions/elementary.html">
       Elementary
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="functions/combinatorial.html">
       Combinatorial
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="functions/special.html">
       Special
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="integrals/index.html">
     Integrals
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
    <label for="toctree-checkbox-5">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="integrals/g-functions.html">
       Computing Integrals using Meijer G-Functions
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="integrals/integrals.html">
       Integrals
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="series/index.html">
     Series
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
    <label for="toctree-checkbox-6">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="series/series.html">
       Series Expansions
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="series/sequences.html">
       Sequences
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="series/fourier.html">
       Fourier Series
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="series/formal.html">
       Formal Power Series
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="series/limitseq.html">
       Limits of Sequences
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="simplify/index.html">
     Simplify
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
    <label for="toctree-checkbox-7">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="simplify/simplify.html">
       Simplify
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="simplify/hyperexpand.html">
       Hypergeometric Expansion
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="simplify/fu.html">
       Hongguang Fu’s Trigonometric Simplification
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="solvers/index.html">
     Solvers
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
    <label for="toctree-checkbox-8">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="solvers/diophantine.html">
       Diophantine
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="solvers/inequalities.html">
       Inequality Solvers
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="solvers/ode.html">
       ODE
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="solvers/pde.html">
       PDE
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="solvers/solvers.html">
       Solvers
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="solvers/solveset.html">
       Solveset
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="abc.html">
     abc
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="algebras.html">
     Algebras
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="concrete.html">
     Concrete
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="core.html">
     Core
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="discrete.html">
     Discrete
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="evalf.html">
     Numerical Evaluation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="numeric-computation.html">
     Numeric Computation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="rewriting.html">
     Term Rewriting
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../reference/public/codegeneration/index.html">
   Code Generation
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
  <label for="toctree-checkbox-9">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="codegen.html">
     Introduction
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="../reference/public/logic/index.html">
   Logic
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Logic
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="sets.html">
     Sets
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../reference/public/matrices/index.html">
   Matrices
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
  <label for="toctree-checkbox-11">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="matrices/index.html">
     Matrices
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/>
    <label for="toctree-checkbox-12">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="matrices/matrices.html">
       Matrices (linear algebra)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="matrices/common.html">
       Common Matrices
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="matrices/dense.html">
       Dense Matrices
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="matrices/sparse.html">
       Sparse Matrices
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="matrices/sparsetools.html">
       Sparse Tools
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="matrices/immutablematrices.html">
       Immutable Matrices
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="matrices/expressions.html">
       Matrix Expressions
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="matrices/normalforms.html">
       Matrix Normal Forms
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="tensor/index.html">
     Tensor
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/>
    <label for="toctree-checkbox-13">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="tensor/array.html">
       N-dim array
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="tensor/indexed.html">
       Indexed Objects
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="tensor/index_methods.html">
       Methods
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="tensor/tensor.html">
       Tensor
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="tensor/toperators.html">
       Tensor Operators
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="vector/index.html">
     Vector
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/>
    <label for="toctree-checkbox-14">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="vector/intro.html">
       Introduction
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="vector/basics.html">
       Basic Implementation details
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="vector/coordsys.html">
       More about Coordinate Systems
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="vector/fields.html">
       Scalar and Vector Field Functionality
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="vector/examples.html">
       General examples of usage
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="vector/vector_integration.html">
       Applications of Vector Integrals
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="vector/api/classes.html">
       Essential Classes in sympy.vector (docstrings)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="vector/api/orienterclasses.html">
       Orienter classes (docstrings)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="vector/api/vectorfunctions.html">
       Essential Functions in sympy.vector (docstrings)
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../reference/public/numbertheory/index.html">
   Number Theory
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" type="checkbox"/>
  <label for="toctree-checkbox-15">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="ntheory.html">
     Ntheory Class Reference
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../reference/public/physics/index.html">
   Physics
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" type="checkbox"/>
  <label for="toctree-checkbox-16">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="physics/hydrogen.html">
     Hydrogen Wavefunctions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="physics/matrices.html">
     Matrices
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="physics/paulialgebra.html">
     Pauli Algebra
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="physics/qho_1d.html">
     Quantum Harmonic Oscillator in 1-D
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="physics/sho.html">
     Quantum Harmonic Oscillator in 3-D
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="physics/secondquant.html">
     Second Quantization
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="physics/wigner.html">
     Wigner Symbols
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="physics/units/index.html">
     Unit systems
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" type="checkbox"/>
    <label for="toctree-checkbox-17">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/units/philosophy.html">
       Philosophy behind unit systems
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/units/examples.html">
       Examples
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/units/dimensions.html">
       Dimensions and dimension systems
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/units/prefixes.html">
       Unit prefixes
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/units/unitsystem.html">
       Units and unit systems
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/units/quantities.html">
       Physical quantities
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="physics/hep/index.html">
     High energy physics
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-18" name="toctree-checkbox-18" type="checkbox"/>
    <label for="toctree-checkbox-18">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul class="simple">
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="physics/vector/index.html">
     The Physics Vector Module
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-19" name="toctree-checkbox-19" type="checkbox"/>
    <label for="toctree-checkbox-19">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/vector/vectors.html">
       Vector &amp; ReferenceFrame
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/vector/kinematics.html">
       Vector: Kinematics
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/vector/advanced.html">
       Potential Issues/Advanced Topics/Future Features in Physics/Vector Module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/vector/fields.html">
       Scalar and Vector Field Functionality
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/vector/api/classes.html">
       Essential Classes
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/vector/api/kinematics.html">
       Kinematics (Docstrings)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/vector/api/printing.html">
       Printing (Docstrings)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/vector/api/functions.html">
       Essential Functions (Docstrings)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/vector/api/fieldfunctions.html">
       Docstrings for basic field functions
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="physics/mechanics/index.html">
     Classical Mechanics
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-20" name="toctree-checkbox-20" type="checkbox"/>
    <label for="toctree-checkbox-20">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/mechanics/masses.html">
       Masses, Inertias, Particles and Rigid Bodies in Physics/Mechanics
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/mechanics/kane.html">
       Kane’s Method in Physics/Mechanics
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/mechanics/lagrange.html">
       Lagrange’s Method in Physics/Mechanics
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/mechanics/symsystem.html">
       Symbolic Systems in Physics/Mechanics
      </a>
     </li>
     <li class="toctree-l3 has-children">
      <a class="reference internal" href="physics/mechanics/linearize.html">
       Linearization in Physics/Mechanics
      </a>
      <input class="toctree-checkbox" id="toctree-checkbox-21" name="toctree-checkbox-21" type="checkbox"/>
      <label for="toctree-checkbox-21">
       <i class="fas fa-chevron-down">
       </i>
      </label>
      <ul>
       <li class="toctree-l4">
        <a class="reference internal" href="physics/mechanics/examples/lin_pend_nonmin_example.html">
         Nonminimal Coordinates Pendulum
        </a>
       </li>
      </ul>
     </li>
     <li class="toctree-l3 has-children">
      <a class="reference internal" href="physics/mechanics/examples.html">
       Examples for Physics/Mechanics
      </a>
      <input class="toctree-checkbox" id="toctree-checkbox-22" name="toctree-checkbox-22" type="checkbox"/>
      <label for="toctree-checkbox-22">
       <i class="fas fa-chevron-down">
       </i>
      </label>
      <ul>
       <li class="toctree-l4">
        <a class="reference internal" href="physics/mechanics/examples/rollingdisc_example.html">
         A rolling disc
        </a>
       </li>
       <li class="toctree-l4">
        <a class="reference internal" href="physics/mechanics/examples/bicycle_example.html">
         A bicycle
        </a>
       </li>
       <li class="toctree-l4">
        <a class="reference internal" href="physics/mechanics/examples/lin_pend_nonmin_example.html">
         Nonminimal Coordinates Pendulum
        </a>
       </li>
       <li class="toctree-l4">
        <a class="reference internal" href="physics/mechanics/examples/multi_degree_freedom_holonomic_system.html">
         Multi Degree of Freedom Holonomic System
        </a>
       </li>
      </ul>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/mechanics/advanced.html">
       Potential Issues/Advanced Topics/Future Features in Physics/Mechanics
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/mechanics/reference.html">
       References for Physics/Mechanics
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/mechanics/autolev_parser.html">
       Autolev Parser
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/mechanics/sympy_mechanics_for_autolev_users.html">
       SymPy Mechanics for Autolev Users
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/mechanics/api/part_bod.html">
       Masses, Inertias &amp; Particles, RigidBodys (Docstrings)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/mechanics/api/kane_lagrange.html">
       Kane’s Method &amp; Lagrange’s Method (Docstrings)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/mechanics/api/system.html">
       SymbolicSystem (Docstrings)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/mechanics/api/linearize.html">
       Linearization (Docstrings)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/mechanics/api/expr_manip.html">
       Expression Manipulation (Docstrings)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/mechanics/api/printing.html">
       Printing (Docstrings)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/mechanics/api/body.html">
       Body (Docstrings)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/mechanics/api/joint.html">
       Joint (Docstrings)
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="physics/quantum/index.html">
     Quantum Mechanics
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-23" name="toctree-checkbox-23" type="checkbox"/>
    <label for="toctree-checkbox-23">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/anticommutator.html">
       Anticommutator
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/cg.html">
       Clebsch-Gordan Coefficients
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/commutator.html">
       Commutator
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/constants.html">
       Constants
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/dagger.html">
       Dagger
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/innerproduct.html">
       Inner Product
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/tensorproduct.html">
       Tensor Product
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/cartesian.html">
       Cartesian Operators and States
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/hilbert.html">
       Hilbert Space
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/operator.html">
       Operator
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/operatorset.html">
       Operator/State Helper Functions
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/qapply.html">
       Qapply
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/represent.html">
       Represent
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/spin.html">
       Spin
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/state.html">
       State
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/circuitplot.html">
       Circuit Plot
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/gate.html">
       Gates
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/grover.html">
       Grover’s Algorithm
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/qft.html">
       QFT
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/qubit.html">
       Qubit
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/shor.html">
       Shor’s Algorithm
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/quantum/piab.html">
       Particle in a Box
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="physics/optics/index.html">
     Optics Module
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-24" name="toctree-checkbox-24" type="checkbox"/>
    <label for="toctree-checkbox-24">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/optics/gaussopt.html">
       Gaussian Optics
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/optics/medium.html">
       Medium
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/optics/polarization.html">
       Polarization
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/optics/utils.html">
       Utilities
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/optics/waves.html">
       Waves
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="physics/control/index.html">
     Control Module
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-25" name="toctree-checkbox-25" type="checkbox"/>
    <label for="toctree-checkbox-25">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/control/control.html">
       Control
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/control/lti.html">
       Control API
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/control/control_plots.html">
       Control System Plots
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="physics/continuum_mechanics/index.html">
     Continuum Mechanics
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-26" name="toctree-checkbox-26" type="checkbox"/>
    <label for="toctree-checkbox-26">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/continuum_mechanics/beam.html">
       Beam (Docstrings)
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="physics/continuum_mechanics/beam_problems.html">
       Solving Beam Bending Problems using Singularity Functions
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../reference/public/utilities/index.html">
   Utilities
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-27" name="toctree-checkbox-27" type="checkbox"/>
  <label for="toctree-checkbox-27">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="testing/index.html">
     Testing
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-28" name="toctree-checkbox-28" type="checkbox"/>
    <label for="toctree-checkbox-28">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="testing/pytest.html">
       pytest
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="testing/randtest.html">
       Randomised Testing
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="testing/runtests.html">
       Run Tests
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="utilities/index.html">
     Utilities
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-29" name="toctree-checkbox-29" type="checkbox"/>
    <label for="toctree-checkbox-29">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="utilities/autowrap.html">
       Autowrap Module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="utilities/codegen.html">
       Codegen
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="utilities/decorator.html">
       Decorator
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="utilities/enumerative.html">
       Enumerative
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="utilities/iterables.html">
       Iterables
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="utilities/lambdify.html">
       Lambdify
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="utilities/memoization.html">
       Memoization
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="utilities/misc.html">
       Miscellaneous
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="utilities/pkgdata.html">
       PKGDATA
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="utilities/source.html">
       Source Code Inspection
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="utilities/timeutils.html">
       Timing Utilities
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="interactive.html">
     Interactive
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="parsing.html">
     Parsing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="printing.html">
     Printing
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../reference/public/topics/index.html">
   Topics
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-30" name="toctree-checkbox-30" type="checkbox"/>
  <label for="toctree-checkbox-30">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="geometry/index.html">
     Geometry
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-31" name="toctree-checkbox-31" type="checkbox"/>
    <label for="toctree-checkbox-31">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="geometry/entities.html">
       Entities
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="geometry/utils.html">
       Utils
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="geometry/points.html">
       Points
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="geometry/lines.html">
       Lines
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="geometry/curves.html">
       Curves
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="geometry/ellipses.html">
       Ellipses
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="geometry/polygons.html">
       Polygons
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="geometry/plane.html">
       Plane
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="holonomic/index.html">
     Holonomic
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-32" name="toctree-checkbox-32" type="checkbox"/>
    <label for="toctree-checkbox-32">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="holonomic/about.html">
       About Holonomic Functions
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="holonomic/represent.html">
       Representation of holonomic functions in SymPy
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="holonomic/operations.html">
       Operations on holonomic functions
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="holonomic/convert.html">
       Converting other representations to holonomic
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="holonomic/uses.html">
       Uses and Current limitations
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="holonomic/internal.html">
       Internal API
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="liealgebras/index.html">
     Lie Algebra
    </a>
   </li>
   <li class="toctree-l2 has-children">
    <a class="reference internal" href="polys/index.html">
     Polynomial Manipulation
    </a>
    <input class="toctree-checkbox" id="toctree-checkbox-33" name="toctree-checkbox-33" type="checkbox"/>
    <label for="toctree-checkbox-33">
     <i class="fas fa-chevron-down">
     </i>
    </label>
    <ul>
     <li class="toctree-l3">
      <a class="reference internal" href="polys/basics.html">
       Basic functionality of the module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="polys/wester.html">
       Examples from Wester’s Article
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="polys/reference.html">
       Polynomials Manipulation Module Reference
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="polys/agca.html">
       AGCA - Algebraic Geometry and Commutative Algebra Module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="polys/domainsintro.html">
       Introducing the Domains of the poly module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="polys/domainsref.html">
       Reference docs for the Poly Domains
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="polys/internals.html">
       Internals of the Polynomial Manipulation Module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="polys/ringseries.html">
       Series Manipulation using Polynomials
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="polys/literature.html">
       Literature
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="polys/solvers.html">
       Poly solvers
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="polys/domainmatrix.html">
       Introducing the domainmatrix of the poly module
      </a>
     </li>
     <li class="toctree-l3">
      <a class="reference internal" href="polys/numberfields.html">
       Number Fields
      </a>
     </li>
    </ul>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="categories.html">
     Category Theory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="crypto.html">
     Cryptography
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="diffgeom.html">
     Differential Geometry
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="plotting.html">
     Plotting
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="stats.html">
     Stats
    </a>
   </li>
  </ul>
 </li>
</ul>

  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   Introduction
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#forming-logical-expressions">
   Forming logical expressions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#boolean-functions">
   Boolean functions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#simplification-and-equivalence-testing">
   Simplification and equivalence-testing
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#manipulating-expressions">
   Manipulating expressions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#truth-tables-and-related-functions">
   Truth tables and related functions
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-sympy.logic.inference">
   Inference
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <section id="module-sympy.logic">
<span id="logic"></span><h1>Logic<a class="headerlink" href="#module-sympy.logic" title="Permalink to this headline">¶</a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The logic module for SymPy allows to form and manipulate logic expressions
using symbolic and Boolean values.</p>
</section>
<section id="forming-logical-expressions">
<h2>Forming logical expressions<a class="headerlink" href="#forming-logical-expressions" title="Permalink to this headline">¶</a></h2>
<p>You can build Boolean expressions with the standard python operators <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>
(<a class="reference internal" href="#sympy.logic.boolalg.And" title="sympy.logic.boolalg.And"><code class="xref py py-class docutils literal notranslate"><span class="pre">And</span></code></a>), <code class="docutils literal notranslate"><span class="pre">|</span></code> (<a class="reference internal" href="#sympy.logic.boolalg.Or" title="sympy.logic.boolalg.Or"><code class="xref py py-class docutils literal notranslate"><span class="pre">Or</span></code></a>), <code class="docutils literal notranslate"><span class="pre">~</span></code> (<a class="reference internal" href="#sympy.logic.boolalg.Not" title="sympy.logic.boolalg.Not"><code class="xref py py-class docutils literal notranslate"><span class="pre">Not</span></code></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span>
<span class="go">y | (x &amp; y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">|</span> <span class="n">y</span>
<span class="go">x | y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">~</span><span class="n">x</span>
<span class="go">~x</span>
</pre></div>
</div>
<p>You can also form implications with <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span>
<span class="go">Implies(x, y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">y</span>
<span class="go">Implies(y, x)</span>
</pre></div>
</div>
<p>Like most types in SymPy, Boolean expressions inherit from <a class="reference internal" href="core.html#sympy.core.basic.Basic" title="sympy.core.basic.Basic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Basic</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">y</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">|</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<p>The logic module also includes the following functions to derive boolean expressions
from their truth tables:</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.SOPform">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">SOPform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minterms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dontcares</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L2330-L2396"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.SOPform" title="Permalink to this definition">¶</a></dt>
<dd><p>The SOPform function uses simplified_pairs and a redundant group-
eliminating algorithm to convert the list of all input combos that
generate ‘1’ (the minterms) into the smallest Sum of Products form.</p>
<p>The variables must be given as the first argument.</p>
<p>Return a logical Or function (i.e., the “sum of products” or “SOP”
form) that gives the desired outcome. If there are inputs that can
be ignored, pass them as a list, too.</p>
<p>The result will be one of the (perhaps many) functions that satisfy
the conditions.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic</span> <span class="kn">import</span> <span class="n">SOPform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;w x y z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">minterms</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dontcares</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SOPform</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">minterms</span><span class="p">,</span> <span class="n">dontcares</span><span class="p">)</span>
<span class="go">(y &amp; z) | (~w &amp; ~x)</span>
</pre></div>
</div>
<p>The terms can also be represented as integers:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minterms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dontcares</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SOPform</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">minterms</span><span class="p">,</span> <span class="n">dontcares</span><span class="p">)</span>
<span class="go">(y &amp; z) | (~w &amp; ~x)</span>
</pre></div>
</div>
<p>They can also be specified using dicts, which does not have to be fully
specified:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minterms</span> <span class="o">=</span> <span class="p">[{</span><span class="n">w</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SOPform</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">minterms</span><span class="p">)</span>
<span class="go">(x &amp; ~w) | (y &amp; z &amp; ~x)</span>
</pre></div>
</div>
<p>Or a combination:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minterms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dontcares</span> <span class="o">=</span> <span class="p">[{</span><span class="n">w</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SOPform</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">minterms</span><span class="p">,</span> <span class="n">dontcares</span><span class="p">)</span>
<span class="go">(w &amp; y &amp; z) | (~w &amp; ~y) | (x &amp; z &amp; ~w)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r550"><span class="brackets"><a class="fn-backref" href="#id1">R550</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm">https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.POSform">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">POSform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minterms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dontcares</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L2405-L2478"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.POSform" title="Permalink to this definition">¶</a></dt>
<dd><p>The POSform function uses simplified_pairs and a redundant-group
eliminating algorithm to convert the list of all input combinations
that generate ‘1’ (the minterms) into the smallest Product of Sums form.</p>
<p>The variables must be given as the first argument.</p>
<p>Return a logical And function (i.e., the “product of sums” or “POS”
form) that gives the desired outcome. If there are inputs that can
be ignored, pass them as a list, too.</p>
<p>The result will be one of the (perhaps many) functions that satisfy
the conditions.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic</span> <span class="kn">import</span> <span class="n">POSform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;w x y z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">minterms</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dontcares</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POSform</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">minterms</span><span class="p">,</span> <span class="n">dontcares</span><span class="p">)</span>
<span class="go">z &amp; (y | ~w)</span>
</pre></div>
</div>
<p>The terms can also be represented as integers:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minterms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dontcares</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POSform</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">minterms</span><span class="p">,</span> <span class="n">dontcares</span><span class="p">)</span>
<span class="go">z &amp; (y | ~w)</span>
</pre></div>
</div>
<p>They can also be specified using dicts, which does not have to be fully
specified:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minterms</span> <span class="o">=</span> <span class="p">[{</span><span class="n">w</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POSform</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">minterms</span><span class="p">)</span>
<span class="go">(x | y) &amp; (x | z) &amp; (~w | ~x)</span>
</pre></div>
</div>
<p>Or a combination:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minterms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dontcares</span> <span class="o">=</span> <span class="p">[{</span><span class="n">w</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POSform</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">minterms</span><span class="p">,</span> <span class="n">dontcares</span><span class="p">)</span>
<span class="go">(w | x) &amp; (y | ~w) &amp; (z | ~y)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r551"><span class="brackets"><a class="fn-backref" href="#id2">R551</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm">https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.ANFform">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">ANFform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">truthvalues</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L2481-L2540"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.ANFform" title="Permalink to this definition">¶</a></dt>
<dd><p>The ANFform function converts the list of truth values to
Algebraic Normal Form (ANF).</p>
<p>The variables must be given as the first argument.</p>
<p>Return True, False, logical And funciton (i.e., the
“Zhegalkin monomial”) or logical Xor function (i.e.,
the “Zhegalkin polynomial”). When True and False
are represented by 1 and 0, respectively, then
And is multiplication and Xor is addition.</p>
<p>Formally a “Zhegalkin monomial” is the product (logical
And) of a finite set of distinct variables, including
the empty set whose product is denoted 1 (True).
A “Zhegalkin polynomial” is the sum (logical Xor) of a
set of Zhegalkin monomials, with the empty set denoted
by 0 (False).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variables</strong> : list of variables</p>
<p><strong>truthvalues</strong> : list of 1’s and 0’s (result column of truth table)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">ANFform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ANFform</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">x ^ True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ANFform</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">x ^ y ^ (x &amp; y)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r552"><span class="brackets"><a class="fn-backref" href="#id3">R552</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Zhegalkin_polynomial">https://en.wikipedia.org/wiki/Zhegalkin_polynomial</a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="boolean-functions">
<h2>Boolean functions<a class="headerlink" href="#boolean-functions" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Boolean">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Boolean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L65-L198"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>A Boolean object is an object for which logic operations make sense.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Boolean.as_set">
<span class="sig-name descname"><span class="pre">as_set</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L135-L182"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Boolean.as_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrites Boolean expression in terms of real sets.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">And</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">{0}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">Interval.open(0, oo)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">And</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">Interval.open(-2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Or</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">Union(Interval.open(-oo, -2), Interval.open(2, oo))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Boolean.equals">
<span class="sig-name descname"><span class="pre">equals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L105-L129"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Boolean.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the given formulas have the same truth table.
For two formulas to be equal they must have the same literals.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">And</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">Not</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">A</span> <span class="o">&gt;&gt;</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="o">~</span><span class="n">B</span> <span class="o">&gt;&gt;</span> <span class="o">~</span><span class="n">A</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">Not</span><span class="p">(</span><span class="n">B</span><span class="p">),</span> <span class="n">Not</span><span class="p">(</span><span class="n">C</span><span class="p">)))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Not</span><span class="p">(</span><span class="n">A</span><span class="p">)))</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">Not</span><span class="p">(</span><span class="n">B</span><span class="p">)))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.BooleanTrue">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">BooleanTrue</span></span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L253-L367"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.BooleanTrue" title="Permalink to this definition">¶</a></dt>
<dd><p>SymPy version of <code class="docutils literal notranslate"><span class="pre">True</span></code>, a singleton that can be accessed via <code class="docutils literal notranslate"><span class="pre">S.true</span></code>.</p>
<p>This is the SymPy version of <code class="docutils literal notranslate"><span class="pre">True</span></code>, for use in the logic module. The
primary advantage of using <code class="docutils literal notranslate"><span class="pre">true</span></code> instead of <code class="docutils literal notranslate"><span class="pre">True</span></code> is that shorthand Boolean
operations like <code class="docutils literal notranslate"><span class="pre">~</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> will work as expected on this class, whereas with
True they act bitwise on 1. Functions in the logic module will return this
class when they evaluate to true.</p>
<p class="rubric">Notes</p>
<p>There is liable to be some confusion as to when <code class="docutils literal notranslate"><span class="pre">True</span></code> should
be used and when <code class="docutils literal notranslate"><span class="pre">S.true</span></code> should be used in various contexts
throughout SymPy. An important thing to remember is that
<code class="docutils literal notranslate"><span class="pre">sympify(True)</span></code> returns <code class="docutils literal notranslate"><span class="pre">S.true</span></code>. This means that for the most
part, you can just use <code class="docutils literal notranslate"><span class="pre">True</span></code> and it will automatically be converted
to <code class="docutils literal notranslate"><span class="pre">S.true</span></code> when necessary, similar to how you can generally use 1
instead of <code class="docutils literal notranslate"><span class="pre">S.One</span></code>.</p>
<p>The rule of thumb is:</p>
<p>“If the boolean in question can be replaced by an arbitrary symbolic
<code class="docutils literal notranslate"><span class="pre">Boolean</span></code>, like <code class="docutils literal notranslate"><span class="pre">Or(x,</span> <span class="pre">y)</span></code> or <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, use <code class="docutils literal notranslate"><span class="pre">S.true</span></code>.
Otherwise, use <code class="docutils literal notranslate"><span class="pre">True</span></code>”</p>
<p>In other words, use <code class="docutils literal notranslate"><span class="pre">S.true</span></code> only on those contexts where the
boolean is being used as a symbolic representation of truth.
For example, if the object ends up in the <code class="docutils literal notranslate"><span class="pre">.args</span></code> of any expression,
then it must necessarily be <code class="docutils literal notranslate"><span class="pre">S.true</span></code> instead of <code class="docutils literal notranslate"><span class="pre">True</span></code>, as
elements of <code class="docutils literal notranslate"><span class="pre">.args</span></code> must be <code class="docutils literal notranslate"><span class="pre">Basic</span></code>. On the other hand,
<code class="docutils literal notranslate"><span class="pre">==</span></code> is not a symbolic operation in SymPy, since it always returns
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>, and does so in terms of structural equality
rather than mathematical, so it should return <code class="docutils literal notranslate"><span class="pre">True</span></code>. The assumptions
system should use <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code>. Aside from not satisfying
the above rule of thumb, the assumptions system uses a three-valued logic
(<code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>), whereas <code class="docutils literal notranslate"><span class="pre">S.true</span></code> and <code class="docutils literal notranslate"><span class="pre">S.false</span></code>
represent a two-valued logic. When in doubt, use <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>“<code class="docutils literal notranslate"><span class="pre">S.true</span> <span class="pre">==</span> <span class="pre">True</span> <span class="pre">is</span> <span class="pre">True</span></code>.”</p>
<p>While “<code class="docutils literal notranslate"><span class="pre">S.true</span> <span class="pre">is</span> <span class="pre">True</span></code>” is <code class="docutils literal notranslate"><span class="pre">False</span></code>, “<code class="docutils literal notranslate"><span class="pre">S.true</span> <span class="pre">==</span> <span class="pre">True</span></code>”
is <code class="docutils literal notranslate"><span class="pre">True</span></code>, so if there is any doubt over whether a function or
expression will return <code class="docutils literal notranslate"><span class="pre">S.true</span></code> or <code class="docutils literal notranslate"><span class="pre">True</span></code>, just use <code class="docutils literal notranslate"><span class="pre">==</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">is</span></code> to do the comparison, and it will work in either
case.  Finally, for boolean flags, it’s better to just use <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">x</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">x</span> <span class="pre">is</span> <span class="pre">True</span></code>. To quote PEP 8:</p>
<p>Don’t compare boolean values to <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>
using <code class="docutils literal notranslate"><span class="pre">==</span></code>.</p>
<ul class="simple">
<li><p>Yes:   <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">greeting:</span></code></p></li>
<li><p>No:    <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">greeting</span> <span class="pre">==</span> <span class="pre">True:</span></code></p></li>
<li><p>Worse: <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">greeting</span> <span class="pre">is</span> <span class="pre">True:</span></code></p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">false</span><span class="p">,</span> <span class="n">Or</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sympify</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">,</span> <span class="n">_</span> <span class="ow">is</span> <span class="n">true</span>
<span class="go">(False, True)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Or</span><span class="p">(</span><span class="n">true</span><span class="p">,</span> <span class="n">false</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="ow">is</span> <span class="n">true</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Python operators give a boolean result for true but a
bitwise result for True</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">~</span><span class="n">true</span><span class="p">,</span> <span class="o">~</span><span class="kc">True</span>
<span class="go">(False, -2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">true</span> <span class="o">&gt;&gt;</span> <span class="n">true</span><span class="p">,</span> <span class="kc">True</span> <span class="o">&gt;&gt;</span> <span class="kc">True</span>
<span class="go">(True, 0)</span>
</pre></div>
</div>
<p>Python operators give a boolean result for true but a
bitwise result for True</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">~</span><span class="n">true</span><span class="p">,</span> <span class="o">~</span><span class="kc">True</span>
<span class="go">(False, -2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">true</span> <span class="o">&gt;&gt;</span> <span class="n">true</span><span class="p">,</span> <span class="kc">True</span> <span class="o">&gt;&gt;</span> <span class="kc">True</span>
<span class="go">(True, 0)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.logic.boolalg.BooleanFalse" title="sympy.logic.boolalg.BooleanFalse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.logic.boolalg.BooleanFalse</span></code></a></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sympy.logic.boolalg.BooleanTrue.as_set">
<span class="sig-name descname"><span class="pre">as_set</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L355-L367"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.BooleanTrue.as_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrite logic operators and relationals in terms of real sets.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">true</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">true</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">UniversalSet</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.BooleanFalse">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">BooleanFalse</span></span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L370-L434"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.BooleanFalse" title="Permalink to this definition">¶</a></dt>
<dd><p>SymPy version of <code class="docutils literal notranslate"><span class="pre">False</span></code>, a singleton that can be accessed via <code class="docutils literal notranslate"><span class="pre">S.false</span></code>.</p>
<p>This is the SymPy version of <code class="docutils literal notranslate"><span class="pre">False</span></code>, for use in the logic module. The
primary advantage of using <code class="docutils literal notranslate"><span class="pre">false</span></code> instead of <code class="docutils literal notranslate"><span class="pre">False</span></code> is that shorthand
Boolean operations like <code class="docutils literal notranslate"><span class="pre">~</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> will work as expected on this class,
whereas with <code class="docutils literal notranslate"><span class="pre">False</span></code> they act bitwise on 0. Functions in the logic module
will return this class when they evaluate to false.</p>
<p class="rubric">Notes</p>
<p>See the notes section in <a class="reference internal" href="#sympy.logic.boolalg.BooleanTrue" title="sympy.logic.boolalg.BooleanTrue"><code class="xref py py-class docutils literal notranslate"><span class="pre">sympy.logic.boolalg.BooleanTrue</span></code></a></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">false</span><span class="p">,</span> <span class="n">Or</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sympify</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">,</span> <span class="n">_</span> <span class="ow">is</span> <span class="n">false</span>
<span class="go">(False, True)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Or</span><span class="p">(</span><span class="n">true</span><span class="p">,</span> <span class="n">false</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="ow">is</span> <span class="n">true</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Python operators give a boolean result for false but a
bitwise result for False</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">~</span><span class="n">false</span><span class="p">,</span> <span class="o">~</span><span class="kc">False</span>
<span class="go">(True, -1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">false</span> <span class="o">&gt;&gt;</span> <span class="n">false</span><span class="p">,</span> <span class="kc">False</span> <span class="o">&gt;&gt;</span> <span class="kc">False</span>
<span class="go">(True, 0)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.logic.boolalg.BooleanTrue" title="sympy.logic.boolalg.BooleanTrue"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.logic.boolalg.BooleanTrue</span></code></a></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sympy.logic.boolalg.BooleanFalse.as_set">
<span class="sig-name descname"><span class="pre">as_set</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L423-L434"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.BooleanFalse.as_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewrite logic operators and relationals in terms of real sets.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">false</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">false</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">EmptySet</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.And">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">And</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L558-L715"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.And" title="Permalink to this definition">¶</a></dt>
<dd><p>Logical AND function.</p>
<p>It evaluates its arguments in order, returning false immediately
when an argument is false and true if they are all true.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">And</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span>
<span class="go">x &amp; y</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> operator is provided as a convenience, but note that its use
here is different from its normal use in Python, which is bitwise
and. Hence, <code class="docutils literal notranslate"><span class="pre">And(a,</span> <span class="pre">b)</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;</span> <span class="pre">b</span></code> will return different things if
<code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are integers.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">And</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">y</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Or">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L718-L821"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Or" title="Permalink to this definition">¶</a></dt>
<dd><p>Logical OR function</p>
<p>It evaluates its arguments in order, returning true immediately
when an  argument is true, and false if they are all false.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Or</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">|</span> <span class="n">y</span>
<span class="go">x | y</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The <code class="docutils literal notranslate"><span class="pre">|</span></code> operator is provided as a convenience, but note that its use
here is different from its normal use in Python, which is bitwise
or. Hence, <code class="docutils literal notranslate"><span class="pre">Or(a,</span> <span class="pre">b)</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">|</span> <span class="pre">b</span></code> will return different things if
<code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are integers.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Or</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">y</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Not">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Not</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L824-L934"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Not" title="Permalink to this definition">¶</a></dt>
<dd><p>Logical Not function (negation)</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the statement is <code class="docutils literal notranslate"><span class="pre">false</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.
Returns <code class="docutils literal notranslate"><span class="pre">false</span></code> if the statement is <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Not</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">Or</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">Or</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">)))</span>
<span class="go">~x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">~</span><span class="n">x</span>
<span class="go">~x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="n">Or</span><span class="p">(</span><span class="o">~</span><span class="n">A</span><span class="p">,</span> <span class="o">~</span><span class="n">B</span><span class="p">)))</span>
<span class="go">~((A | B) &amp; (~A | ~B))</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">~</span></code> operator is provided as a convenience, but note that its use
here is different from its normal use in Python, which is bitwise
not. In particular, <code class="docutils literal notranslate"><span class="pre">~a</span></code> and <code class="docutils literal notranslate"><span class="pre">Not(a)</span></code> will be different if <code class="docutils literal notranslate"><span class="pre">a</span></code> is
an integer. Furthermore, since bools in Python subclass from <code class="docutils literal notranslate"><span class="pre">int</span></code>,
<code class="docutils literal notranslate"><span class="pre">~True</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">~1</span></code> which is <code class="docutils literal notranslate"><span class="pre">-2</span></code>, which has a boolean
value of True.  To avoid this issue, use the SymPy boolean types
<code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">true</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">~</span><span class="kc">True</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">~</span><span class="n">true</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Xor">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Xor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L937-L1069"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Xor" title="Permalink to this definition">¶</a></dt>
<dd><p>Logical XOR (exclusive OR) function.</p>
<p>Returns True if an odd number of the arguments are True and the rest are
False.</p>
<p>Returns False if an even number of the arguments are True and the rest are
False.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Xor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">^</span> <span class="n">y</span>
<span class="go">x ^ y</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The <code class="docutils literal notranslate"><span class="pre">^</span></code> operator is provided as a convenience, but note that its use
here is different from its normal use in Python, which is bitwise xor. In
particular, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">^</span> <span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">Xor(a,</span> <span class="pre">b)</span></code> will be different if <code class="docutils literal notranslate"><span class="pre">a</span></code> and
<code class="docutils literal notranslate"><span class="pre">b</span></code> are integers.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">x</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Nand">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Nand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1072-L1098"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Nand" title="Permalink to this definition">¶</a></dt>
<dd><p>Logical NAND function.</p>
<p>It evaluates its arguments in order, giving True immediately if any
of them are False, and False if they are all True.</p>
<p>Returns True if any of the arguments are False
Returns False if all arguments are True</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Nand</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Nand</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Nand</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Nand</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">~(x &amp; y)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Nor">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Nor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1101-L1132"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Nor" title="Permalink to this definition">¶</a></dt>
<dd><p>Logical NOR function.</p>
<p>It evaluates its arguments in order, giving False immediately if any
of them are True, and True if they are all False.</p>
<p>Returns False if any argument is True
Returns True if all arguments are False</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Nor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Nor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Nor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Nor</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Nor</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Nor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">~(x | y)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Xnor">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Xnor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1135-L1163"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Xnor" title="Permalink to this definition">¶</a></dt>
<dd><p>Logical XNOR function.</p>
<p>Returns False if an odd number of the arguments are True and the rest are
False.</p>
<p>Returns True if an even number of the arguments are True and the rest are
False.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Xnor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xnor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xnor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xnor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xnor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Implies">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Implies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1166-L1247"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Implies" title="Permalink to this definition">¶</a></dt>
<dd><p>Logical implication.</p>
<p>A implies B is equivalent to if A then B. Mathematically, it is written
as <span class="math notranslate nohighlight">\(A \Rightarrow B\)</span> and is equivalent to <span class="math notranslate nohighlight">\(\neg A \vee B\)</span> or <code class="docutils literal notranslate"><span class="pre">~A</span> <span class="pre">|</span> <span class="pre">B</span></code>.</p>
<p>Accepts two Boolean arguments; A and B.
Returns False if A is True and B is False
Returns True otherwise.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Implies</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Implies</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Implies</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Implies</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Implies</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span>
<span class="go">Implies(x, y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">x</span>
<span class="go">Implies(x, y)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> operators are provided as a convenience, but note
that their use here is different from their normal use in Python, which is
bit shifts. Hence, <code class="docutils literal notranslate"><span class="pre">Implies(a,</span> <span class="pre">b)</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;&gt;</span> <span class="pre">b</span></code> will return different
things if <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are integers.  In particular, since Python
considers <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code> to be integers, <code class="docutils literal notranslate"><span class="pre">True</span> <span class="pre">&gt;&gt;</span> <span class="pre">True</span></code> will be
the same as <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&gt;&gt;</span> <span class="pre">1</span></code>, i.e., 0, which has a truth value of False.  To
avoid this issue, use the SymPy objects <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">true</span><span class="p">,</span> <span class="n">false</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kc">True</span> <span class="o">&gt;&gt;</span> <span class="kc">False</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">true</span> <span class="o">&gt;&gt;</span> <span class="n">false</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Equivalent">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Equivalent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1250-L1331"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Equivalent" title="Permalink to this definition">¶</a></dt>
<dd><p>Equivalence relation.</p>
<p><code class="docutils literal notranslate"><span class="pre">Equivalent(A,</span> <span class="pre">B)</span></code> is True iff A and B are both True or both False.</p>
<p>Returns True if all of the arguments are logically equivalent.
Returns False otherwise.</p>
<p>For two arguments, this is equivalent to <a class="reference internal" href="#sympy.logic.boolalg.Xnor" title="sympy.logic.boolalg.Xnor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Xnor</span></code></a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Equivalent</span><span class="p">,</span> <span class="n">And</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Equivalent</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Equivalent</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Equivalent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">And</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.ITE">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">ITE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1334-L1445"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.ITE" title="Permalink to this definition">¶</a></dt>
<dd><p>If-then-else clause.</p>
<p><code class="docutils literal notranslate"><span class="pre">ITE(A,</span> <span class="pre">B,</span> <span class="pre">C)</span></code> evaluates and returns the result of B if A is true
else it returns the result of C. All args must be Booleans.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">ITE</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">Xor</span><span class="p">,</span> <span class="n">Or</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ITE</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ITE</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="n">And</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">Xor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ITE</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">ITE(x, y, z)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ITE</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ITE</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ITE</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">y</span>
</pre></div>
</div>
<p>Trying to use non-Boolean args will generate a TypeError:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ITE</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="p">[],</span> <span class="p">())</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">expecting bool, Boolean or ITE, not `[]`</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Exclusive">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Exclusive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1448-L1473"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Exclusive" title="Permalink to this definition">¶</a></dt>
<dd><p>True if only one or no argument is true.</p>
<p><code class="docutils literal notranslate"><span class="pre">Exclusive(A,</span> <span class="pre">B,</span> <span class="pre">C)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">~(A</span> <span class="pre">&amp;</span> <span class="pre">B)</span> <span class="pre">&amp;</span> <span class="pre">~(A</span> <span class="pre">&amp;</span> <span class="pre">C)</span> <span class="pre">&amp;</span> <span class="pre">~(B</span> <span class="pre">&amp;</span> <span class="pre">C)</span></code>.</p>
<p>For two arguments, this is equivalent to <a class="reference internal" href="#sympy.logic.boolalg.Xor" title="sympy.logic.boolalg.Xor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Xor</span></code></a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Exclusive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Exclusive</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Exclusive</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Exclusive</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<p>The following functions can be used to handle Algebraic, Conjunctive,
Disjunctive, and Negated Normal forms:</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.to_anf">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">to_anf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1592-L1633"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.to_anf" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts expr to Algebraic Normal Form (ANF).</p>
<p>ANF is a canonical normal form, which means that two
equivalent formulas will convert to the same ANF.</p>
<p>A logical expression is in ANF if it has the form</p>
<div class="math notranslate nohighlight">
\[1 \oplus a \oplus b \oplus ab \oplus abc\]</div>
<dl class="simple">
<dt>i.e. it can be:</dt><dd><ul class="simple">
<li><p>purely true,</p></li>
<li><p>purely false,</p></li>
<li><p>conjunction of variables,</p></li>
<li><p>exclusive disjunction.</p></li>
</ul>
</dd>
</dl>
<p>The exclusive disjunction can only contain true, variables
or conjunction of variables. No negations are permitted.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">deep</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, arguments of the boolean
expression are considered variables, i.e. only the
top-level expression is converted to ANF.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">And</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">Not</span><span class="p">,</span> <span class="n">Implies</span><span class="p">,</span> <span class="n">Equivalent</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">to_anf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_anf</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="go">A ^ True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_anf</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="n">Not</span><span class="p">(</span><span class="n">C</span><span class="p">)))</span>
<span class="go">A ^ B ^ (A &amp; B) ^ (A &amp; C) ^ (B &amp; C) ^ (A &amp; B &amp; C)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_anf</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">Equivalent</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">)),</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">True ^ ~A ^ (~A &amp; (Equivalent(B, C)))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.to_cnf">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">to_cnf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplify</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1660-L1699"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.to_cnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a propositional logical sentence <code class="docutils literal notranslate"><span class="pre">expr</span></code> to conjunctive normal
form: <code class="docutils literal notranslate"><span class="pre">((A</span> <span class="pre">|</span> <span class="pre">~B</span> <span class="pre">|</span> <span class="pre">...)</span> <span class="pre">&amp;</span> <span class="pre">(B</span> <span class="pre">|</span> <span class="pre">C</span> <span class="pre">|</span> <span class="pre">...)</span> <span class="pre">&amp;</span> <span class="pre">...)</span></code>.
If <code class="docutils literal notranslate"><span class="pre">simplify</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">expr</span></code> is evaluated to its simplest CNF
form using the Quine-McCluskey algorithm; this may take a long
time if there are more than 8 variables and requires that the
<code class="docutils literal notranslate"><span class="pre">force</span></code> flag be set to <code class="docutils literal notranslate"><span class="pre">True</span></code> (default is <code class="docutils literal notranslate"><span class="pre">False</span></code>).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">to_cnf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_cnf</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">A</span> <span class="o">|</span> <span class="n">B</span><span class="p">)</span> <span class="o">|</span> <span class="n">D</span><span class="p">)</span>
<span class="go">(D | ~A) &amp; (D | ~B)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_cnf</span><span class="p">((</span><span class="n">A</span> <span class="o">|</span> <span class="n">B</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">A</span> <span class="o">|</span> <span class="o">~</span><span class="n">A</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">A | B</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.to_dnf">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">to_dnf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplify</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1702-L1739"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.to_dnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a propositional logical sentence <code class="docutils literal notranslate"><span class="pre">expr</span></code> to disjunctive normal
form: <code class="docutils literal notranslate"><span class="pre">((A</span> <span class="pre">&amp;</span> <span class="pre">~B</span> <span class="pre">&amp;</span> <span class="pre">...)</span> <span class="pre">|</span> <span class="pre">(B</span> <span class="pre">&amp;</span> <span class="pre">C</span> <span class="pre">&amp;</span> <span class="pre">...)</span> <span class="pre">|</span> <span class="pre">...)</span></code>.
If <code class="docutils literal notranslate"><span class="pre">simplify</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">expr</span></code> is evaluated to its simplest DNF form using
the Quine-McCluskey algorithm; this may take a long
time if there are more than 8 variables and requires that the
<code class="docutils literal notranslate"><span class="pre">force</span></code> flag be set to <code class="docutils literal notranslate"><span class="pre">True</span></code> (default is <code class="docutils literal notranslate"><span class="pre">False</span></code>).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">to_dnf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_dnf</span><span class="p">(</span><span class="n">B</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">A</span> <span class="o">|</span> <span class="n">C</span><span class="p">))</span>
<span class="go">(A &amp; B) | (B &amp; C)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_dnf</span><span class="p">((</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">B</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">B</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">B</span> <span class="o">&amp;</span> <span class="n">C</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">B</span> <span class="o">&amp;</span> <span class="n">C</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">A | C</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.to_nnf">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">to_nnf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplify</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1636-L1657"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.to_nnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts <code class="docutils literal notranslate"><span class="pre">expr</span></code> to Negation Normal Form (NNF).</p>
<p>A logical expression is in NNF if it
contains only And, Or and Not, and Not is applied only to literals.
If <code class="docutils literal notranslate"><span class="pre">simplify</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the result contains no redundant clauses.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Not</span><span class="p">,</span> <span class="n">Equivalent</span><span class="p">,</span> <span class="n">to_nnf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_nnf</span><span class="p">(</span><span class="n">Not</span><span class="p">((</span><span class="o">~</span><span class="n">A</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">B</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">C</span> <span class="o">&amp;</span> <span class="n">D</span><span class="p">)))</span>
<span class="go">(A | B) &amp; (~C | ~D)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_nnf</span><span class="p">(</span><span class="n">Equivalent</span><span class="p">(</span><span class="n">A</span> <span class="o">&gt;&gt;</span> <span class="n">B</span><span class="p">,</span> <span class="n">B</span> <span class="o">&gt;&gt;</span> <span class="n">A</span><span class="p">))</span>
<span class="go">(A | ~B | (A &amp; ~B)) &amp; (B | ~A | (B &amp; ~A))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.is_anf">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">is_anf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1742-L1794"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.is_anf" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if <code class="docutils literal notranslate"><span class="pre">expr</span></code>  is in Algebraic Normal Form (ANF).</p>
<p>A logical expression is in ANF if it has the form</p>
<div class="math notranslate nohighlight">
\[1 \oplus a \oplus b \oplus ab \oplus abc\]</div>
<p>i.e. it is purely true, purely false, conjunction of
variables or exclusive disjunction. The exclusive
disjunction can only contain true, variables or
conjunction of variables. No negations are permitted.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">And</span><span class="p">,</span> <span class="n">Not</span><span class="p">,</span> <span class="n">Xor</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">is_anf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_anf</span><span class="p">(</span><span class="n">true</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_anf</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_anf</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_anf</span><span class="p">(</span><span class="n">Xor</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Not</span><span class="p">(</span><span class="n">B</span><span class="p">)))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.is_cnf">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">is_cnf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1845-L1862"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.is_cnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether or not an expression is in conjunctive normal form.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">is_cnf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_cnf</span><span class="p">(</span><span class="n">A</span> <span class="o">|</span> <span class="n">B</span> <span class="o">|</span> <span class="n">C</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_cnf</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">B</span> <span class="o">&amp;</span> <span class="n">C</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_cnf</span><span class="p">((</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">B</span><span class="p">)</span> <span class="o">|</span> <span class="n">C</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.is_dnf">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">is_dnf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1865-L1884"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.is_dnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether or not an expression is in disjunctive normal form.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">is_dnf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_dnf</span><span class="p">(</span><span class="n">A</span> <span class="o">|</span> <span class="n">B</span> <span class="o">|</span> <span class="n">C</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_dnf</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">B</span> <span class="o">&amp;</span> <span class="n">C</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_dnf</span><span class="p">((</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">B</span><span class="p">)</span> <span class="o">|</span> <span class="n">C</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_dnf</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">B</span> <span class="o">|</span> <span class="n">C</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.is_nnf">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">is_nnf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplified</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1797-L1842"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.is_nnf" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if <code class="docutils literal notranslate"><span class="pre">expr</span></code> is in Negation Normal Form (NNF).</p>
<p>A logical expression is in NNF if it
contains only And, Or and Not, and Not is applied only to literals.
If <code class="docutils literal notranslate"><span class="pre">simplified</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, checks if result contains no redundant clauses.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Not</span><span class="p">,</span> <span class="n">is_nnf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_nnf</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">B</span> <span class="o">|</span> <span class="o">~</span><span class="n">C</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_nnf</span><span class="p">((</span><span class="n">A</span> <span class="o">|</span> <span class="o">~</span><span class="n">A</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">B</span> <span class="o">|</span> <span class="n">C</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_nnf</span><span class="p">((</span><span class="n">A</span> <span class="o">|</span> <span class="o">~</span><span class="n">A</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">B</span> <span class="o">|</span> <span class="n">C</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_nnf</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">B</span><span class="p">)</span> <span class="o">|</span> <span class="n">C</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_nnf</span><span class="p">((</span><span class="n">A</span> <span class="o">&gt;&gt;</span> <span class="n">B</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">B</span> <span class="o">&gt;&gt;</span> <span class="n">A</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="simplification-and-equivalence-testing">
<h2>Simplification and equivalence-testing<a class="headerlink" href="#simplification-and-equivalence-testing" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.simplify_logic">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">simplify_logic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">form</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L2723-L2823"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.simplify_logic" title="Permalink to this definition">¶</a></dt>
<dd><p>This function simplifies a boolean function to its simplified version
in SOP or POS form. The return type is an Or or And object in SymPy.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>expr</strong> : Boolean expression</p>
<p><strong>form</strong> : string (<code class="docutils literal notranslate"><span class="pre">'cnf'</span></code> or <code class="docutils literal notranslate"><span class="pre">'dnf'</span></code>) or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default).</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">'cnf'</span></code> or <code class="docutils literal notranslate"><span class="pre">'dnf'</span></code>, the simplest expression in the corresponding
normal form is returned; if <code class="docutils literal notranslate"><span class="pre">None</span></code>, the answer is returned
according to the form with fewest args (in CNF by default).</p>
</div></blockquote>
<p><strong>deep</strong> : bool (default <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>Indicates whether to recursively simplify any
non-boolean functions contained within the input.</p>
</div></blockquote>
<p><strong>force</strong> : bool (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>As the simplifications require exponential time in the number
of variables, there is by default a limit on expressions with
8 variables. When the expression has more than 8 variables
only symbolical simplification (controlled by <code class="docutils literal notranslate"><span class="pre">deep</span></code>) is
made. By setting <code class="docutils literal notranslate"><span class="pre">force</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code>, this limit is removed. Be
aware that this can lead to very long simplification times.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic</span> <span class="kn">import</span> <span class="n">simplify_logic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">y</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">z</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span> <span class="o">~</span><span class="n">x</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">y</span> <span class="o">&amp;</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">simplify_logic</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">~x &amp; ~y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">(z &amp; ~x &amp; ~y) | (~x &amp; ~y &amp; ~z)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">simplify_logic</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="go">~x &amp; ~y</span>
</pre></div>
</div>
</dd></dl>

<p>SymPy’s <a class="reference internal" href="simplify/simplify.html#sympy.simplify.simplify.simplify" title="sympy.simplify.simplify.simplify"><code class="xref py py-func docutils literal notranslate"><span class="pre">simplify()</span></code></a> function can also be used to simplify logic expressions to their
simplest forms.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.bool_map">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">bool_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bool1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bool2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L2910-L2992"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.bool_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the simplified version of <em>bool1</em>, and the mapping of variables
that makes the two expressions <em>bool1</em> and <em>bool2</em> represent the same
logical behaviour for some correspondence between the variables
of each.
If more than one mappings of this sort exist, one of them
is returned.</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">And(x,</span> <span class="pre">y)</span></code> is logically equivalent to <code class="docutils literal notranslate"><span class="pre">And(a,</span> <span class="pre">b)</span></code> for
the mapping <code class="docutils literal notranslate"><span class="pre">{x:</span> <span class="pre">a,</span> <span class="pre">y:</span> <span class="pre">b}</span></code> or <code class="docutils literal notranslate"><span class="pre">{x:</span> <span class="pre">b,</span> <span class="pre">y:</span> <span class="pre">a}</span></code>.
If no such mapping exists, return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">SOPform</span><span class="p">,</span> <span class="n">bool_map</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">Not</span><span class="p">,</span> <span class="n">Xor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">function1</span> <span class="o">=</span> <span class="n">SOPform</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">function2</span> <span class="o">=</span> <span class="n">SOPform</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_map</span><span class="p">(</span><span class="n">function1</span><span class="p">,</span> <span class="n">function2</span><span class="p">)</span>
<span class="go">(y &amp; ~z, {y: a, z: b})</span>
</pre></div>
</div>
<p>The results are not necessarily unique, but they are canonical. Here,
<code class="docutils literal notranslate"><span class="pre">(w,</span> <span class="pre">z)</span></code> could be <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">d)</span></code> or <code class="docutils literal notranslate"><span class="pre">(d,</span> <span class="pre">a)</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span>  <span class="n">Or</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">w</span><span class="p">),</span> <span class="n">And</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">z</span><span class="p">),</span> <span class="n">And</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq2</span> <span class="o">=</span> <span class="n">Or</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="p">),</span> <span class="n">And</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">d</span><span class="p">),</span> <span class="n">And</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_map</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">eq2</span><span class="p">)</span>
<span class="go">((x &amp; y) | (w &amp; ~y) | (z &amp; ~y), {w: a, x: b, y: c, z: d})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">And</span><span class="p">(</span><span class="n">Xor</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">,</span> <span class="n">And</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_map</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="go">(c &amp; d &amp; (a | b) &amp; (~a | ~b), {a: a, b: b, c: d, d: x})</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="manipulating-expressions">
<h2>Manipulating expressions<a class="headerlink" href="#manipulating-expressions" title="Permalink to this headline">¶</a></h2>
<p>The following functions can be used to manipulate Boolean expressions:</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.distribute_and_over_or">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">distribute_and_over_or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1513-L1527"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.distribute_and_over_or" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sentence <code class="docutils literal notranslate"><span class="pre">expr</span></code> consisting of conjunctions and disjunctions
of literals, return an equivalent sentence in CNF.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">distribute_and_over_or</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">Not</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distribute_and_over_or</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">And</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">B</span><span class="p">),</span> <span class="n">Not</span><span class="p">(</span><span class="n">C</span><span class="p">))))</span>
<span class="go">(A | ~B) &amp; (A | ~C)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.distribute_or_over_and">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">distribute_or_over_and</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1530-L1546"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.distribute_or_over_and" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sentence <code class="docutils literal notranslate"><span class="pre">expr</span></code> consisting of conjunctions and disjunctions
of literals, return an equivalent sentence in DNF.</p>
<p>Note that the output is NOT simplified.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">distribute_or_over_and</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">Not</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distribute_or_over_and</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">B</span><span class="p">),</span> <span class="n">C</span><span class="p">))</span>
<span class="go">(B &amp; C) | (C &amp; ~A)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.distribute_xor_over_and">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">distribute_xor_over_and</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1549-L1565"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.distribute_xor_over_and" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sentence <code class="docutils literal notranslate"><span class="pre">expr</span></code> consisting of conjunction and
exclusive disjunctions of literals, return an
equivalent exclusive disjunction.</p>
<p>Note that the output is NOT simplified.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">distribute_xor_over_and</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">Xor</span><span class="p">,</span> <span class="n">Not</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distribute_xor_over_and</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">Xor</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">B</span><span class="p">),</span> <span class="n">C</span><span class="p">))</span>
<span class="go">(B &amp; C) ^ (C &amp; ~A)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.eliminate_implications">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">eliminate_implications</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1907-L1928"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.eliminate_implications" title="Permalink to this definition">¶</a></dt>
<dd><p>Change <code class="docutils literal notranslate"><span class="pre">Implies</span></code> and <code class="docutils literal notranslate"><span class="pre">Equivalent</span></code> into <code class="docutils literal notranslate"><span class="pre">And</span></code>, <code class="docutils literal notranslate"><span class="pre">Or</span></code>, and <code class="docutils literal notranslate"><span class="pre">Not</span></code>.
That is, return an expression that is equivalent to <code class="docutils literal notranslate"><span class="pre">expr</span></code>, but has only
<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, and <code class="docutils literal notranslate"><span class="pre">~</span></code> as logical
operators.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Implies</span><span class="p">,</span> <span class="n">Equivalent</span><span class="p">,</span>          <span class="n">eliminate_implications</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eliminate_implications</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>
<span class="go">B | ~A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eliminate_implications</span><span class="p">(</span><span class="n">Equivalent</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>
<span class="go">(A | ~B) &amp; (B | ~A)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eliminate_implications</span><span class="p">(</span><span class="n">Equivalent</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
<span class="go">(A | ~C) &amp; (B | ~A) &amp; (C | ~B)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="truth-tables-and-related-functions">
<h2>Truth tables and related functions<a class="headerlink" href="#truth-tables-and-related-functions" title="Permalink to this headline">¶</a></h2>
<p>It is possible to create a truth table for a Boolean function with</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.truth_table">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">truth_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L2018-L2083"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.truth_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a generator of all possible configurations of the input variables,
and the result of the boolean expression for those values.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>expr</strong> : Boolean expression</p>
<p><strong>variables</strong> : list of variables</p>
<p><strong>input</strong> : bool (default <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>Indicates whether to return the input combinations.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">truth_table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">truth_table</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> -&gt; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">))</span>
<span class="go">[0, 0] -&gt; True</span>
<span class="go">[0, 1] -&gt; True</span>
<span class="go">[1, 0] -&gt; False</span>
<span class="go">[1, 1] -&gt; True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">truth_table</span><span class="p">(</span><span class="n">x</span> <span class="o">|</span> <span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
<span class="go">[([0, 0], False), ([0, 1], True), ([1, 0], True), ([1, 1], True)]</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">input</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">truth_table</span></code> returns only a list of truth values.
In this case, the corresponding input values of variables can be
deduced from the index of a given output.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">ibin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">truth_table</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span>
<span class="go">[True, False, True, True]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> -&gt; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
<span class="gp">... </span>    <span class="nb">vars</span><span class="p">,</span> <span class="n">ibin</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">vars</span><span class="p">)))),</span> <span class="n">value</span><span class="p">))</span>
<span class="go">[(y, 0), (x, 0)] -&gt; True</span>
<span class="go">[(y, 0), (x, 1)] -&gt; False</span>
<span class="go">[(y, 1), (x, 0)] -&gt; True</span>
<span class="go">[(y, 1), (x, 1)] -&gt; True</span>
</pre></div>
</div>
</dd></dl>

<p>For mapping between integer representations of truth table positions, lists of
zeros and ones and symbols, the following functions can be used:</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.integer_to_term">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">integer_to_term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">str</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/utilities/iterables.py#L330-L399"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.integer_to_term" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of length <code class="docutils literal notranslate"><span class="pre">bits</span></code> corresponding to the binary value
of <code class="docutils literal notranslate"><span class="pre">n</span></code> with small bits to the right (last). If bits is omitted, the
length will be the number required to represent <code class="docutils literal notranslate"><span class="pre">n</span></code>. If the bits are
desired in reversed order, use the <code class="docutils literal notranslate"><span class="pre">[::-1]</span></code> slice of the returned list.</p>
<p>If a sequence of all bits-length lists starting from <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0,...,</span> <span class="pre">0]</span></code>
through <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">1,</span> <span class="pre">...,</span> <span class="pre">1]</span></code> are desired, pass a non-integer for bits, e.g.
<code class="docutils literal notranslate"><span class="pre">'all'</span></code>.</p>
<p>If the bit <em>string</em> is desired pass <code class="docutils literal notranslate"><span class="pre">str=True</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">ibin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ibin</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[1, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ibin</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">[0, 0, 1, 0]</span>
</pre></div>
</div>
<p>If all lists corresponding to 0 to 2**n - 1, pass a non-integer
for bits:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bits</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ibin</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">(0, 0)</span>
<span class="go">(0, 1)</span>
<span class="go">(1, 0)</span>
<span class="go">(1, 1)</span>
</pre></div>
</div>
<p>If a bit string is desired of a given length, use str=True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">123</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bits</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ibin</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="nb">str</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;0001111011&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ibin</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="nb">str</span><span class="o">=</span><span class="kc">True</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># small bits left</span>
<span class="go">&#39;1101111000&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">ibin</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;011&#39;, &#39;100&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.term_to_integer">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">term_to_integer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">term</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1992-L2012"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.term_to_integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an integer corresponding to the base-2 digits given by <code class="docutils literal notranslate"><span class="pre">term</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>term</strong> : a string or list of ones and zeros</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">term_to_integer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">term_to_integer</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">term_to_integer</span><span class="p">(</span><span class="s1">&#39;100&#39;</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.bool_maxterm">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">bool_maxterm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L2634-L2667"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.bool_maxterm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the k-th maxterm.</p>
<p>Each maxterm is assigned an index based on the opposite
conventional binary encoding used for minterms. The maxterm
convention assigns the value 0 to the direct form and 1 to
the complemented form.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>k</strong> : int or list of 1’s and 0’s (complementation pattern)</p>
<p><strong>variables</strong> : list of variables</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">bool_maxterm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_maxterm</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">y | ~x | ~z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_maxterm</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">z | ~x | ~y</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r553"><span class="brackets"><a class="fn-backref" href="#id4">R553</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_maxterms">https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_maxterms</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.bool_minterm">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">bool_minterm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L2598-L2631"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.bool_minterm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the k-th minterm.</p>
<p>Minterms are numbered by a binary encoding of the complementation
pattern of the variables. This convention assigns the value 1 to
the direct form and 0 to the complemented form.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>k</strong> : int or list of 1’s and 0’s (complementation patter)</p>
<p><strong>variables</strong> : list of variables</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">bool_minterm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_minterm</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">x &amp; z &amp; ~y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_minterm</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">x &amp; y &amp; ~z</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r554"><span class="brackets"><a class="fn-backref" href="#id5">R554</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_minterms">https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_minterms</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.bool_monomial">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">bool_monomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L2670-L2708"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.bool_monomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the k-th monomial.</p>
<p>Monomials are numbered by a binary encoding of the presence and
absences of the variables. This convention assigns the value
1 to the presence of variable and 0 to the absence of variable.</p>
<p>Each boolean function can be uniquely represented by a
Zhegalkin Polynomial (Algebraic Normal Form). The Zhegalkin
Polynomial of the boolean function with <span class="math notranslate nohighlight">\(n\)</span> variables can contain
up to <span class="math notranslate nohighlight">\(2^n\)</span> monomials. We can enumarate all the monomials.
Each monomial is fully specified by the presence or absence
of each variable.</p>
<p>For example, boolean function with four variables <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d)</span></code>
can contain up to <span class="math notranslate nohighlight">\(2^4 = 16\)</span> monomials. The 13-th monomial is the
product <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;</span> <span class="pre">b</span> <span class="pre">&amp;</span> <span class="pre">d</span></code>, because 13 in binary is 1, 1, 0, 1.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>k</strong> : int or list of 1’s and 0’s</p>
<p><strong>variables</strong> : list of variables</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">bool_monomial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_monomial</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">x &amp; z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_monomial</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">x &amp; y</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.anf_coeffs">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">anf_coeffs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">truthvalues</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L2543-L2595"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.anf_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list of truth values of some boolean expression
to the list of coefficients of the polynomial mod 2 (exclusive
disjunction) representing the boolean expression in ANF
(i.e., the “Zhegalkin polynomial”).</p>
<p>There are <span class="math notranslate nohighlight">\(2^n\)</span> possible Zhegalkin monomials in <span class="math notranslate nohighlight">\(n\)</span> variables, since
each monomial is fully specified by the presence or absence of
each variable.</p>
<p>We can enumerate all the monomials. For example, boolean
function with four variables <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d)</span></code> can contain
up to <span class="math notranslate nohighlight">\(2^4 = 16\)</span> monomials. The 13-th monomial is the
product <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;</span> <span class="pre">b</span> <span class="pre">&amp;</span> <span class="pre">d</span></code>, because 13 in binary is 1, 1, 0, 1.</p>
<p>A given monomial’s presence or absence in a polynomial corresponds
to that monomial’s coefficient being 1 or 0 respectively.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">anf_coeffs</span><span class="p">,</span> <span class="n">bool_monomial</span><span class="p">,</span> <span class="n">Xor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">truthvalues</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coeffs</span> <span class="o">=</span> <span class="n">anf_coeffs</span><span class="p">(</span><span class="n">truthvalues</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coeffs</span>
<span class="go">[0, 1, 1, 0, 0, 0, 1, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polynomial</span> <span class="o">=</span> <span class="n">Xor</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
<span class="gp">... </span>    <span class="n">bool_monomial</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span> <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">1</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polynomial</span>
<span class="go">b ^ c ^ (a &amp; b)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.to_int_repr">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">to_int_repr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clauses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbols</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/boolalg.py#L1965-L1989"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.to_int_repr" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes clauses in CNF format and puts them into an integer representation.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">to_int_repr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_int_repr</span><span class="p">([</span><span class="n">x</span> <span class="o">|</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span> <span class="o">==</span> <span class="p">[{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">}]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-sympy.logic.inference">
<span id="inference"></span><h2>Inference<a class="headerlink" href="#module-sympy.logic.inference" title="Permalink to this headline">¶</a></h2>
<p>This module implements some inference routines in propositional logic.</p>
<p>The function satisfiable will test that a given Boolean expression is satisfiable,
that is, you can assign values to the variables to make the sentence <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>For example, the expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&amp;</span> <span class="pre">~x</span></code> is not satisfiable, since there are no
values for <code class="docutils literal notranslate"><span class="pre">x</span></code> that make this sentence <code class="docutils literal notranslate"><span class="pre">True</span></code>. On the other hand, <code class="docutils literal notranslate"><span class="pre">(x</span>
<span class="pre">|</span> <span class="pre">y)</span> <span class="pre">&amp;</span> <span class="pre">(x</span> <span class="pre">|</span> <span class="pre">~y)</span> <span class="pre">&amp;</span> <span class="pre">(~x</span> <span class="pre">|</span> <span class="pre">y)</span></code> is satisfiable with both <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> being
<code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.inference</span> <span class="kn">import</span> <span class="n">satisfiable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">satisfiable</span><span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">satisfiable</span><span class="p">((</span><span class="n">x</span> <span class="o">|</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">|</span> <span class="o">~</span><span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">|</span> <span class="n">y</span><span class="p">))</span>
<span class="go">{x: True, y: True}</span>
</pre></div>
</div>
<p>As you see, when a sentence is satisfiable, it returns a model that makes that
sentence <code class="docutils literal notranslate"><span class="pre">True</span></code>. If it is not satisfiable it will return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.inference.satisfiable">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.inference.</span></span><span class="sig-name descname"><span class="pre">satisfiable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_models</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/9f425283552d9fc2ef0c9fdda8367377a370e85e/sympy/logic/inference.py#L38-L108"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.inference.satisfiable" title="Permalink to this definition">¶</a></dt>
<dd><p>Check satisfiability of a propositional sentence.
Returns a model when it succeeds.
Returns {true: true} for trivially true expressions.</p>
<p>On setting all_models to True, if given expr is satisfiable then
returns a generator of models. However, if expr is unsatisfiable
then returns a generator containing the single element False.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.inference</span> <span class="kn">import</span> <span class="n">satisfiable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">satisfiable</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">B</span><span class="p">)</span>
<span class="go">{A: True, B: False}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">satisfiable</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">A</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">satisfiable</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{True: True}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">satisfiable</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">A</span><span class="p">,</span> <span class="n">all_models</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">models</span> <span class="o">=</span> <span class="n">satisfiable</span><span class="p">((</span><span class="n">A</span> <span class="o">&gt;&gt;</span> <span class="n">B</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">B</span><span class="p">,</span> <span class="n">all_models</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">models</span><span class="p">)</span>
<span class="go">{A: False, B: True}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">models</span><span class="p">)</span>
<span class="go">{A: True, B: True}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">use_models</span><span class="p">(</span><span class="n">models</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">model</span><span class="p">:</span>
<span class="gp">... </span>            <span class="c1"># Do something with the model.</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>            <span class="c1"># Given expr is unsatisfiable.</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;UNSAT&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">use_models</span><span class="p">(</span><span class="n">satisfiable</span><span class="p">(</span><span class="n">A</span> <span class="o">&gt;&gt;</span> <span class="o">~</span><span class="n">A</span><span class="p">,</span> <span class="n">all_models</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">{A: False}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">use_models</span><span class="p">(</span><span class="n">satisfiable</span><span class="p">(</span><span class="n">A</span> <span class="o">^</span> <span class="n">A</span><span class="p">,</span> <span class="n">all_models</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">UNSAT</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="../reference/public/logic/index.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Logic</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="sets.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Sets</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          

      </div>
    </div>
  
    <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
  <footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2022 SymPy Development Team.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.1.2.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>