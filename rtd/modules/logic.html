<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Logic &mdash; SymPy 1.10.dev documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/plot_directive.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/sympy-notailtext-favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script src="../_static/js/theme.js"></script>
    <link href="https://docs.sympy.org/latest/modules/logic.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Sets" href="sets.html" />
    <link rel="prev" title="Logic" href="../reference/public/logic/index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> SymPy
            <img src="../_static/sympylogo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.10.dev
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">SymPy Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/index.html">SymPy Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../explanation/index.html">Explanation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../reference/index.html">Reference Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../reference/index.html#basics"><span class="xref std std-ref">Basics</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/index.html#code-generation"><span class="xref std std-ref">Code Generation</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/index.html#logic"><span class="xref std std-ref">Logic</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/index.html#matrices"><span class="xref std std-ref">Matrices</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/index.html#number-theory"><span class="xref std std-ref">Number Theory</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/index.html#physics"><span class="xref std std-ref">Physics</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/index.html#utilities"><span class="xref std std-ref">Utilities</span></a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../reference/index.html#topics"><span class="xref std std-ref">Topics</span></a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../reference/public/basics/index.html">Basics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/public/codegeneration/index.html">Code Generation</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../reference/public/logic/index.html">Logic</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">Logic</a></li>
<li class="toctree-l4"><a class="reference internal" href="sets.html">Sets</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../reference/public/matrices/index.html">Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/public/numbertheory/index.html">Number Theory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/public/physics/index.html">Physics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/public/utilities/index.html">Utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/public/topics/index.html">Topics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../miscellaneous/index.html">Miscellaneous</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SymPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../reference/index.html">Reference Documentation</a> &raquo;</li>
          <li><a href="../reference/public/logic/index.html">Logic</a> &raquo;</li>
      <li>Logic</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/modules/logic.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-sympy.logic">
<span id="logic"></span><h1>Logic<a class="headerlink" href="#module-sympy.logic" title="Permalink to this headline"></a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline"></a></h2>
<p>The logic module for SymPy allows to form and manipulate logic expressions
using symbolic and Boolean values.</p>
</section>
<section id="forming-logical-expressions">
<h2>Forming logical expressions<a class="headerlink" href="#forming-logical-expressions" title="Permalink to this headline"></a></h2>
<p>You can build Boolean expressions with the standard python operators <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>
(<a class="reference internal" href="#sympy.logic.boolalg.And" title="sympy.logic.boolalg.And"><code class="xref py py-class docutils literal notranslate"><span class="pre">And</span></code></a>), <code class="docutils literal notranslate"><span class="pre">|</span></code> (<a class="reference internal" href="#sympy.logic.boolalg.Or" title="sympy.logic.boolalg.Or"><code class="xref py py-class docutils literal notranslate"><span class="pre">Or</span></code></a>), <code class="docutils literal notranslate"><span class="pre">~</span></code> (<a class="reference internal" href="#sympy.logic.boolalg.Not" title="sympy.logic.boolalg.Not"><code class="xref py py-class docutils literal notranslate"><span class="pre">Not</span></code></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span>
<span class="go">y | (x &amp; y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">|</span> <span class="n">y</span>
<span class="go">x | y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">~</span><span class="n">x</span>
<span class="go">~x</span>
</pre></div>
</div>
<p>You can also form implications with <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span>
<span class="go">Implies(x, y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">y</span>
<span class="go">Implies(y, x)</span>
</pre></div>
</div>
<p>Like most types in SymPy, Boolean expressions inherit from <a class="reference internal" href="core.html#sympy.core.basic.Basic" title="sympy.core.basic.Basic"><code class="xref py py-class docutils literal notranslate"><span class="pre">Basic</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">y</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">x</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">|</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span>
<span class="go">{x, y}</span>
</pre></div>
</div>
<p>The logic module also includes the following functions to derive boolean expressions
from their truth tables:</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.SOPform">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">SOPform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minterms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dontcares</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L2330-L2396"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.SOPform" title="Permalink to this definition"></a></dt>
<dd><p>The SOPform function uses simplified_pairs and a redundant group-
eliminating algorithm to convert the list of all input combos that
generate ‘1’ (the minterms) into the smallest Sum of Products form.</p>
<p>The variables must be given as the first argument.</p>
<p>Return a logical Or function (i.e., the “sum of products” or “SOP”
form) that gives the desired outcome. If there are inputs that can
be ignored, pass them as a list, too.</p>
<p>The result will be one of the (perhaps many) functions that satisfy
the conditions.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic</span> <span class="kn">import</span> <span class="n">SOPform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;w x y z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">minterms</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dontcares</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SOPform</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">minterms</span><span class="p">,</span> <span class="n">dontcares</span><span class="p">)</span>
<span class="go">(y &amp; z) | (~w &amp; ~x)</span>
</pre></div>
</div>
<p>The terms can also be represented as integers:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minterms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dontcares</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SOPform</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">minterms</span><span class="p">,</span> <span class="n">dontcares</span><span class="p">)</span>
<span class="go">(y &amp; z) | (~w &amp; ~x)</span>
</pre></div>
</div>
<p>They can also be specified using dicts, which does not have to be fully
specified:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minterms</span> <span class="o">=</span> <span class="p">[{</span><span class="n">w</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SOPform</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">minterms</span><span class="p">)</span>
<span class="go">(x &amp; ~w) | (y &amp; z &amp; ~x)</span>
</pre></div>
</div>
<p>Or a combination:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minterms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dontcares</span> <span class="o">=</span> <span class="p">[{</span><span class="n">w</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SOPform</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">minterms</span><span class="p">,</span> <span class="n">dontcares</span><span class="p">)</span>
<span class="go">(w &amp; y &amp; z) | (~w &amp; ~y) | (x &amp; z &amp; ~w)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r550"><span class="brackets"><a class="fn-backref" href="#id1">R550</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm">https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.POSform">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">POSform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minterms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dontcares</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L2405-L2478"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.POSform" title="Permalink to this definition"></a></dt>
<dd><p>The POSform function uses simplified_pairs and a redundant-group
eliminating algorithm to convert the list of all input combinations
that generate ‘1’ (the minterms) into the smallest Product of Sums form.</p>
<p>The variables must be given as the first argument.</p>
<p>Return a logical And function (i.e., the “product of sums” or “POS”
form) that gives the desired outcome. If there are inputs that can
be ignored, pass them as a list, too.</p>
<p>The result will be one of the (perhaps many) functions that satisfy
the conditions.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic</span> <span class="kn">import</span> <span class="n">POSform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;w x y z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">minterms</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>            <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dontcares</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POSform</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">minterms</span><span class="p">,</span> <span class="n">dontcares</span><span class="p">)</span>
<span class="go">z &amp; (y | ~w)</span>
</pre></div>
</div>
<p>The terms can also be represented as integers:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minterms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dontcares</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POSform</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">minterms</span><span class="p">,</span> <span class="n">dontcares</span><span class="p">)</span>
<span class="go">z &amp; (y | ~w)</span>
</pre></div>
</div>
<p>They can also be specified using dicts, which does not have to be fully
specified:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minterms</span> <span class="o">=</span> <span class="p">[{</span><span class="n">w</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="n">y</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span><span class="p">}]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POSform</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">minterms</span><span class="p">)</span>
<span class="go">(x | y) &amp; (x | z) &amp; (~w | ~x)</span>
</pre></div>
</div>
<p>Or a combination:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minterms</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dontcares</span> <span class="o">=</span> <span class="p">[{</span><span class="n">w</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">POSform</span><span class="p">([</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">minterms</span><span class="p">,</span> <span class="n">dontcares</span><span class="p">)</span>
<span class="go">(w | x) &amp; (y | ~w) &amp; (z | ~y)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r551"><span class="brackets"><a class="fn-backref" href="#id2">R551</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm">https://en.wikipedia.org/wiki/Quine-McCluskey_algorithm</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.ANFform">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">ANFform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">truthvalues</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L2481-L2540"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.ANFform" title="Permalink to this definition"></a></dt>
<dd><p>The ANFform function converts the list of truth values to
Algebraic Normal Form (ANF).</p>
<p>The variables must be given as the first argument.</p>
<p>Return True, False, logical And funciton (i.e., the
“Zhegalkin monomial”) or logical Xor function (i.e.,
the “Zhegalkin polynomial”). When True and False
are represented by 1 and 0, respectively, then
And is multiplication and Xor is addition.</p>
<p>Formally a “Zhegalkin monomial” is the product (logical
And) of a finite set of distinct variables, including
the empty set whose product is denoted 1 (True).
A “Zhegalkin polynomial” is the sum (logical Xor) of a
set of Zhegalkin monomials, with the empty set denoted
by 0 (False).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variables</strong> : list of variables</p>
<p><strong>truthvalues</strong> : list of 1’s and 0’s (result column of truth table)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">ANFform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ANFform</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">x ^ True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ANFform</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">x ^ y ^ (x &amp; y)</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r552"><span class="brackets"><a class="fn-backref" href="#id3">R552</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Zhegalkin_polynomial">https://en.wikipedia.org/wiki/Zhegalkin_polynomial</a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="boolean-functions">
<h2>Boolean functions<a class="headerlink" href="#boolean-functions" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Boolean">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Boolean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L65-L198"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Boolean" title="Permalink to this definition"></a></dt>
<dd><p>A Boolean object is an object for which logic operations make sense.</p>
<dl class="py method">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Boolean.as_set">
<span class="sig-name descname"><span class="pre">as_set</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L135-L182"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Boolean.as_set" title="Permalink to this definition"></a></dt>
<dd><p>Rewrites Boolean expression in terms of real sets.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">Eq</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">And</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">{0}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">Interval.open(0, oo)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">And</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">Interval.open(-2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Or</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">Union(Interval.open(-oo, -2), Interval.open(2, oo))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Boolean.equals">
<span class="sig-name descname"><span class="pre">equals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L105-L129"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Boolean.equals" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the given formulas have the same truth table.
For two formulas to be equal they must have the same literals.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">And</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">Not</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">A</span> <span class="o">&gt;&gt;</span> <span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="o">~</span><span class="n">B</span> <span class="o">&gt;&gt;</span> <span class="o">~</span><span class="n">A</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">Not</span><span class="p">(</span><span class="n">B</span><span class="p">),</span> <span class="n">Not</span><span class="p">(</span><span class="n">C</span><span class="p">)))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Not</span><span class="p">(</span><span class="n">A</span><span class="p">)))</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">Not</span><span class="p">(</span><span class="n">B</span><span class="p">)))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.BooleanTrue">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">BooleanTrue</span></span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L253-L367"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.BooleanTrue" title="Permalink to this definition"></a></dt>
<dd><p>SymPy version of <code class="docutils literal notranslate"><span class="pre">True</span></code>, a singleton that can be accessed via <code class="docutils literal notranslate"><span class="pre">S.true</span></code>.</p>
<p>This is the SymPy version of <code class="docutils literal notranslate"><span class="pre">True</span></code>, for use in the logic module. The
primary advantage of using <code class="docutils literal notranslate"><span class="pre">true</span></code> instead of <code class="docutils literal notranslate"><span class="pre">True</span></code> is that shorthand Boolean
operations like <code class="docutils literal notranslate"><span class="pre">~</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> will work as expected on this class, whereas with
True they act bitwise on 1. Functions in the logic module will return this
class when they evaluate to true.</p>
<p class="rubric">Notes</p>
<p>There is liable to be some confusion as to when <code class="docutils literal notranslate"><span class="pre">True</span></code> should
be used and when <code class="docutils literal notranslate"><span class="pre">S.true</span></code> should be used in various contexts
throughout SymPy. An important thing to remember is that
<code class="docutils literal notranslate"><span class="pre">sympify(True)</span></code> returns <code class="docutils literal notranslate"><span class="pre">S.true</span></code>. This means that for the most
part, you can just use <code class="docutils literal notranslate"><span class="pre">True</span></code> and it will automatically be converted
to <code class="docutils literal notranslate"><span class="pre">S.true</span></code> when necessary, similar to how you can generally use 1
instead of <code class="docutils literal notranslate"><span class="pre">S.One</span></code>.</p>
<p>The rule of thumb is:</p>
<p>“If the boolean in question can be replaced by an arbitrary symbolic
<code class="docutils literal notranslate"><span class="pre">Boolean</span></code>, like <code class="docutils literal notranslate"><span class="pre">Or(x,</span> <span class="pre">y)</span></code> or <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, use <code class="docutils literal notranslate"><span class="pre">S.true</span></code>.
Otherwise, use <code class="docutils literal notranslate"><span class="pre">True</span></code>”</p>
<p>In other words, use <code class="docutils literal notranslate"><span class="pre">S.true</span></code> only on those contexts where the
boolean is being used as a symbolic representation of truth.
For example, if the object ends up in the <code class="docutils literal notranslate"><span class="pre">.args</span></code> of any expression,
then it must necessarily be <code class="docutils literal notranslate"><span class="pre">S.true</span></code> instead of <code class="docutils literal notranslate"><span class="pre">True</span></code>, as
elements of <code class="docutils literal notranslate"><span class="pre">.args</span></code> must be <code class="docutils literal notranslate"><span class="pre">Basic</span></code>. On the other hand,
<code class="docutils literal notranslate"><span class="pre">==</span></code> is not a symbolic operation in SymPy, since it always returns
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>, and does so in terms of structural equality
rather than mathematical, so it should return <code class="docutils literal notranslate"><span class="pre">True</span></code>. The assumptions
system should use <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code>. Aside from not satisfying
the above rule of thumb, the assumptions system uses a three-valued logic
(<code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code>), whereas <code class="docutils literal notranslate"><span class="pre">S.true</span></code> and <code class="docutils literal notranslate"><span class="pre">S.false</span></code>
represent a two-valued logic. When in doubt, use <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>“<code class="docutils literal notranslate"><span class="pre">S.true</span> <span class="pre">==</span> <span class="pre">True</span> <span class="pre">is</span> <span class="pre">True</span></code>.”</p>
<p>While “<code class="docutils literal notranslate"><span class="pre">S.true</span> <span class="pre">is</span> <span class="pre">True</span></code>” is <code class="docutils literal notranslate"><span class="pre">False</span></code>, “<code class="docutils literal notranslate"><span class="pre">S.true</span> <span class="pre">==</span> <span class="pre">True</span></code>”
is <code class="docutils literal notranslate"><span class="pre">True</span></code>, so if there is any doubt over whether a function or
expression will return <code class="docutils literal notranslate"><span class="pre">S.true</span></code> or <code class="docutils literal notranslate"><span class="pre">True</span></code>, just use <code class="docutils literal notranslate"><span class="pre">==</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">is</span></code> to do the comparison, and it will work in either
case.  Finally, for boolean flags, it’s better to just use <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">x</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">x</span> <span class="pre">is</span> <span class="pre">True</span></code>. To quote PEP 8:</p>
<p>Don’t compare boolean values to <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>
using <code class="docutils literal notranslate"><span class="pre">==</span></code>.</p>
<ul class="simple">
<li><p>Yes:   <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">greeting:</span></code></p></li>
<li><p>No:    <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">greeting</span> <span class="pre">==</span> <span class="pre">True:</span></code></p></li>
<li><p>Worse: <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">greeting</span> <span class="pre">is</span> <span class="pre">True:</span></code></p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">false</span><span class="p">,</span> <span class="n">Or</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sympify</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">,</span> <span class="n">_</span> <span class="ow">is</span> <span class="n">true</span>
<span class="go">(False, True)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Or</span><span class="p">(</span><span class="n">true</span><span class="p">,</span> <span class="n">false</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="ow">is</span> <span class="n">true</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Python operators give a boolean result for true but a
bitwise result for True</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">~</span><span class="n">true</span><span class="p">,</span> <span class="o">~</span><span class="kc">True</span>
<span class="go">(False, -2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">true</span> <span class="o">&gt;&gt;</span> <span class="n">true</span><span class="p">,</span> <span class="kc">True</span> <span class="o">&gt;&gt;</span> <span class="kc">True</span>
<span class="go">(True, 0)</span>
</pre></div>
</div>
<p>Python operators give a boolean result for true but a
bitwise result for True</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">~</span><span class="n">true</span><span class="p">,</span> <span class="o">~</span><span class="kc">True</span>
<span class="go">(False, -2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">true</span> <span class="o">&gt;&gt;</span> <span class="n">true</span><span class="p">,</span> <span class="kc">True</span> <span class="o">&gt;&gt;</span> <span class="kc">True</span>
<span class="go">(True, 0)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.logic.boolalg.BooleanFalse" title="sympy.logic.boolalg.BooleanFalse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.logic.boolalg.BooleanFalse</span></code></a></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sympy.logic.boolalg.BooleanTrue.as_set">
<span class="sig-name descname"><span class="pre">as_set</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L355-L367"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.BooleanTrue.as_set" title="Permalink to this definition"></a></dt>
<dd><p>Rewrite logic operators and relationals in terms of real sets.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">true</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">true</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">UniversalSet</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.BooleanFalse">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">BooleanFalse</span></span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L370-L434"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.BooleanFalse" title="Permalink to this definition"></a></dt>
<dd><p>SymPy version of <code class="docutils literal notranslate"><span class="pre">False</span></code>, a singleton that can be accessed via <code class="docutils literal notranslate"><span class="pre">S.false</span></code>.</p>
<p>This is the SymPy version of <code class="docutils literal notranslate"><span class="pre">False</span></code>, for use in the logic module. The
primary advantage of using <code class="docutils literal notranslate"><span class="pre">false</span></code> instead of <code class="docutils literal notranslate"><span class="pre">False</span></code> is that shorthand
Boolean operations like <code class="docutils literal notranslate"><span class="pre">~</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> will work as expected on this class,
whereas with <code class="docutils literal notranslate"><span class="pre">False</span></code> they act bitwise on 0. Functions in the logic module
will return this class when they evaluate to false.</p>
<p class="rubric">Notes</p>
<p>See the notes section in <a class="reference internal" href="#sympy.logic.boolalg.BooleanTrue" title="sympy.logic.boolalg.BooleanTrue"><code class="xref py py-class docutils literal notranslate"><span class="pre">sympy.logic.boolalg.BooleanTrue</span></code></a></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sympify</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">false</span><span class="p">,</span> <span class="n">Or</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sympify</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">,</span> <span class="n">_</span> <span class="ow">is</span> <span class="n">false</span>
<span class="go">(False, True)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Or</span><span class="p">(</span><span class="n">true</span><span class="p">,</span> <span class="n">false</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="ow">is</span> <span class="n">true</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Python operators give a boolean result for false but a
bitwise result for False</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">~</span><span class="n">false</span><span class="p">,</span> <span class="o">~</span><span class="kc">False</span>
<span class="go">(True, -1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">false</span> <span class="o">&gt;&gt;</span> <span class="n">false</span><span class="p">,</span> <span class="kc">False</span> <span class="o">&gt;&gt;</span> <span class="kc">False</span>
<span class="go">(True, 0)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#sympy.logic.boolalg.BooleanTrue" title="sympy.logic.boolalg.BooleanTrue"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sympy.logic.boolalg.BooleanTrue</span></code></a></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="sympy.logic.boolalg.BooleanFalse.as_set">
<span class="sig-name descname"><span class="pre">as_set</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L423-L434"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.BooleanFalse.as_set" title="Permalink to this definition"></a></dt>
<dd><p>Rewrite logic operators and relationals in terms of real sets.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">false</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">false</span><span class="o">.</span><span class="n">as_set</span><span class="p">()</span>
<span class="go">EmptySet</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.And">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">And</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L558-L715"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.And" title="Permalink to this definition"></a></dt>
<dd><p>Logical AND function.</p>
<p>It evaluates its arguments in order, returning false immediately
when an argument is false and true if they are all true.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">And</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span>
<span class="go">x &amp; y</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> operator is provided as a convenience, but note that its use
here is different from its normal use in Python, which is bitwise
and. Hence, <code class="docutils literal notranslate"><span class="pre">And(a,</span> <span class="pre">b)</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;</span> <span class="pre">b</span></code> will return different things if
<code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are integers.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">And</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">y</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Or">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L718-L821"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Or" title="Permalink to this definition"></a></dt>
<dd><p>Logical OR function</p>
<p>It evaluates its arguments in order, returning true immediately
when an  argument is true, and false if they are all false.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Or</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">|</span> <span class="n">y</span>
<span class="go">x | y</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The <code class="docutils literal notranslate"><span class="pre">|</span></code> operator is provided as a convenience, but note that its use
here is different from its normal use in Python, which is bitwise
or. Hence, <code class="docutils literal notranslate"><span class="pre">Or(a,</span> <span class="pre">b)</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">|</span> <span class="pre">b</span></code> will return different things if
<code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are integers.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Or</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">y</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Not">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Not</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L824-L934"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Not" title="Permalink to this definition"></a></dt>
<dd><p>Logical Not function (negation)</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the statement is <code class="docutils literal notranslate"><span class="pre">false</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.
Returns <code class="docutils literal notranslate"><span class="pre">false</span></code> if the statement is <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Not</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">Or</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">Or</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">)))</span>
<span class="go">~x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">~</span><span class="n">x</span>
<span class="go">~x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Not</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="n">Or</span><span class="p">(</span><span class="o">~</span><span class="n">A</span><span class="p">,</span> <span class="o">~</span><span class="n">B</span><span class="p">)))</span>
<span class="go">~((A | B) &amp; (~A | ~B))</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">~</span></code> operator is provided as a convenience, but note that its use
here is different from its normal use in Python, which is bitwise
not. In particular, <code class="docutils literal notranslate"><span class="pre">~a</span></code> and <code class="docutils literal notranslate"><span class="pre">Not(a)</span></code> will be different if <code class="docutils literal notranslate"><span class="pre">a</span></code> is
an integer. Furthermore, since bools in Python subclass from <code class="docutils literal notranslate"><span class="pre">int</span></code>,
<code class="docutils literal notranslate"><span class="pre">~True</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">~1</span></code> which is <code class="docutils literal notranslate"><span class="pre">-2</span></code>, which has a boolean
value of True.  To avoid this issue, use the SymPy boolean types
<code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
</ul>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">true</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">~</span><span class="kc">True</span>
<span class="go">-2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">~</span><span class="n">true</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Xor">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Xor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L937-L1069"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Xor" title="Permalink to this definition"></a></dt>
<dd><p>Logical XOR (exclusive OR) function.</p>
<p>Returns True if an odd number of the arguments are True and the rest are
False.</p>
<p>Returns False if an even number of the arguments are True and the rest are
False.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Xor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">^</span> <span class="n">y</span>
<span class="go">x ^ y</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The <code class="docutils literal notranslate"><span class="pre">^</span></code> operator is provided as a convenience, but note that its use
here is different from its normal use in Python, which is bitwise xor. In
particular, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">^</span> <span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">Xor(a,</span> <span class="pre">b)</span></code> will be different if <code class="docutils literal notranslate"><span class="pre">a</span></code> and
<code class="docutils literal notranslate"><span class="pre">b</span></code> are integers.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">x</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Nand">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Nand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1072-L1098"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Nand" title="Permalink to this definition"></a></dt>
<dd><p>Logical NAND function.</p>
<p>It evaluates its arguments in order, giving True immediately if any
of them are False, and False if they are all True.</p>
<p>Returns True if any of the arguments are False
Returns False if all arguments are True</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Nand</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Nand</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Nand</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Nand</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">~(x &amp; y)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Nor">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Nor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1101-L1132"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Nor" title="Permalink to this definition"></a></dt>
<dd><p>Logical NOR function.</p>
<p>It evaluates its arguments in order, giving False immediately if any
of them are True, and True if they are all False.</p>
<p>Returns False if any argument is True
Returns True if all arguments are False</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Nor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Nor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Nor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Nor</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Nor</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Nor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">~(x | y)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Xnor">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Xnor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1135-L1163"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Xnor" title="Permalink to this definition"></a></dt>
<dd><p>Logical XNOR function.</p>
<p>Returns False if an odd number of the arguments are True and the rest are
False.</p>
<p>Returns True if an even number of the arguments are True and the rest are
False.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Xnor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xnor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xnor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xnor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Xnor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Implies">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Implies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1166-L1247"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Implies" title="Permalink to this definition"></a></dt>
<dd><p>Logical implication.</p>
<p>A implies B is equivalent to if A then B. Mathematically, it is written
as <span class="math notranslate nohighlight">\(A \Rightarrow B\)</span> and is equivalent to <span class="math notranslate nohighlight">\(\neg A \vee B\)</span> or <code class="docutils literal notranslate"><span class="pre">~A</span> <span class="pre">|</span> <span class="pre">B</span></code>.</p>
<p>Accepts two Boolean arguments; A and B.
Returns False if A is True and B is False
Returns True otherwise.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Implies</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x y&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Implies</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Implies</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Implies</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Implies</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span>
<span class="go">Implies(x, y)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="n">x</span>
<span class="go">Implies(x, y)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> operators are provided as a convenience, but note
that their use here is different from their normal use in Python, which is
bit shifts. Hence, <code class="docutils literal notranslate"><span class="pre">Implies(a,</span> <span class="pre">b)</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&gt;&gt;</span> <span class="pre">b</span></code> will return different
things if <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are integers.  In particular, since Python
considers <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code> to be integers, <code class="docutils literal notranslate"><span class="pre">True</span> <span class="pre">&gt;&gt;</span> <span class="pre">True</span></code> will be
the same as <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&gt;&gt;</span> <span class="pre">1</span></code>, i.e., 0, which has a truth value of False.  To
avoid this issue, use the SymPy objects <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">true</span><span class="p">,</span> <span class="n">false</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kc">True</span> <span class="o">&gt;&gt;</span> <span class="kc">False</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">true</span> <span class="o">&gt;&gt;</span> <span class="n">false</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Equivalent">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Equivalent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1250-L1331"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Equivalent" title="Permalink to this definition"></a></dt>
<dd><p>Equivalence relation.</p>
<p><code class="docutils literal notranslate"><span class="pre">Equivalent(A,</span> <span class="pre">B)</span></code> is True iff A and B are both True or both False.</p>
<p>Returns True if all of the arguments are logically equivalent.
Returns False otherwise.</p>
<p>For two arguments, this is equivalent to <a class="reference internal" href="#sympy.logic.boolalg.Xnor" title="sympy.logic.boolalg.Xnor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Xnor</span></code></a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Equivalent</span><span class="p">,</span> <span class="n">And</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Equivalent</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Equivalent</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Equivalent</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">And</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.ITE">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">ITE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1334-L1445"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.ITE" title="Permalink to this definition"></a></dt>
<dd><p>If-then-else clause.</p>
<p><code class="docutils literal notranslate"><span class="pre">ITE(A,</span> <span class="pre">B,</span> <span class="pre">C)</span></code> evaluates and returns the result of B if A is true
else it returns the result of C. All args must be Booleans.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">ITE</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">Xor</span><span class="p">,</span> <span class="n">Or</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ITE</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ITE</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="n">And</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">Xor</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ITE</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="go">ITE(x, y, z)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ITE</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ITE</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ITE</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">y</span>
</pre></div>
</div>
<p>Trying to use non-Boolean args will generate a TypeError:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ITE</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="p">[],</span> <span class="p">())</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">expecting bool, Boolean or ITE, not `[]`</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="sympy.logic.boolalg.Exclusive">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">Exclusive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1448-L1473"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.Exclusive" title="Permalink to this definition"></a></dt>
<dd><p>True if only one or no argument is true.</p>
<p><code class="docutils literal notranslate"><span class="pre">Exclusive(A,</span> <span class="pre">B,</span> <span class="pre">C)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">~(A</span> <span class="pre">&amp;</span> <span class="pre">B)</span> <span class="pre">&amp;</span> <span class="pre">~(A</span> <span class="pre">&amp;</span> <span class="pre">C)</span> <span class="pre">&amp;</span> <span class="pre">~(B</span> <span class="pre">&amp;</span> <span class="pre">C)</span></code>.</p>
<p>For two arguments, this is equivalent to <a class="reference internal" href="#sympy.logic.boolalg.Xor" title="sympy.logic.boolalg.Xor"><code class="xref py py-class docutils literal notranslate"><span class="pre">Xor</span></code></a>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Exclusive</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Exclusive</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Exclusive</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Exclusive</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<p>The following functions can be used to handle Algebraic, Conjunctive,
Disjunctive, and Negated Normal forms:</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.to_anf">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">to_anf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1592-L1633"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.to_anf" title="Permalink to this definition"></a></dt>
<dd><p>Converts expr to Algebraic Normal Form (ANF).</p>
<p>ANF is a canonical normal form, which means that two
equivalent formulas will convert to the same ANF.</p>
<p>A logical expression is in ANF if it has the form</p>
<div class="math notranslate nohighlight">
\[1 \oplus a \oplus b \oplus ab \oplus abc\]</div>
<dl class="simple">
<dt>i.e. it can be:</dt><dd><ul class="simple">
<li><p>purely true,</p></li>
<li><p>purely false,</p></li>
<li><p>conjunction of variables,</p></li>
<li><p>exclusive disjunction.</p></li>
</ul>
</dd>
</dl>
<p>The exclusive disjunction can only contain true, variables
or conjunction of variables. No negations are permitted.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">deep</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, arguments of the boolean
expression are considered variables, i.e. only the
top-level expression is converted to ANF.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">And</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">Not</span><span class="p">,</span> <span class="n">Implies</span><span class="p">,</span> <span class="n">Equivalent</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">to_anf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_anf</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="go">A ^ True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_anf</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="n">Not</span><span class="p">(</span><span class="n">C</span><span class="p">)))</span>
<span class="go">A ^ B ^ (A &amp; B) ^ (A &amp; C) ^ (B &amp; C) ^ (A &amp; B &amp; C)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_anf</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">Equivalent</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">)),</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">True ^ ~A ^ (~A &amp; (Equivalent(B, C)))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.to_cnf">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">to_cnf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplify</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1660-L1699"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.to_cnf" title="Permalink to this definition"></a></dt>
<dd><p>Convert a propositional logical sentence <code class="docutils literal notranslate"><span class="pre">expr</span></code> to conjunctive normal
form: <code class="docutils literal notranslate"><span class="pre">((A</span> <span class="pre">|</span> <span class="pre">~B</span> <span class="pre">|</span> <span class="pre">...)</span> <span class="pre">&amp;</span> <span class="pre">(B</span> <span class="pre">|</span> <span class="pre">C</span> <span class="pre">|</span> <span class="pre">...)</span> <span class="pre">&amp;</span> <span class="pre">...)</span></code>.
If <code class="docutils literal notranslate"><span class="pre">simplify</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">expr</span></code> is evaluated to its simplest CNF
form using the Quine-McCluskey algorithm; this may take a long
time if there are more than 8 variables and requires that the
<code class="docutils literal notranslate"><span class="pre">force</span></code> flag be set to <code class="docutils literal notranslate"><span class="pre">True</span></code> (default is <code class="docutils literal notranslate"><span class="pre">False</span></code>).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">to_cnf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_cnf</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">A</span> <span class="o">|</span> <span class="n">B</span><span class="p">)</span> <span class="o">|</span> <span class="n">D</span><span class="p">)</span>
<span class="go">(D | ~A) &amp; (D | ~B)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_cnf</span><span class="p">((</span><span class="n">A</span> <span class="o">|</span> <span class="n">B</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">A</span> <span class="o">|</span> <span class="o">~</span><span class="n">A</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">A | B</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.to_dnf">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">to_dnf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplify</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1702-L1739"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.to_dnf" title="Permalink to this definition"></a></dt>
<dd><p>Convert a propositional logical sentence <code class="docutils literal notranslate"><span class="pre">expr</span></code> to disjunctive normal
form: <code class="docutils literal notranslate"><span class="pre">((A</span> <span class="pre">&amp;</span> <span class="pre">~B</span> <span class="pre">&amp;</span> <span class="pre">...)</span> <span class="pre">|</span> <span class="pre">(B</span> <span class="pre">&amp;</span> <span class="pre">C</span> <span class="pre">&amp;</span> <span class="pre">...)</span> <span class="pre">|</span> <span class="pre">...)</span></code>.
If <code class="docutils literal notranslate"><span class="pre">simplify</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">expr</span></code> is evaluated to its simplest DNF form using
the Quine-McCluskey algorithm; this may take a long
time if there are more than 8 variables and requires that the
<code class="docutils literal notranslate"><span class="pre">force</span></code> flag be set to <code class="docutils literal notranslate"><span class="pre">True</span></code> (default is <code class="docutils literal notranslate"><span class="pre">False</span></code>).</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">to_dnf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_dnf</span><span class="p">(</span><span class="n">B</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">A</span> <span class="o">|</span> <span class="n">C</span><span class="p">))</span>
<span class="go">(A &amp; B) | (B &amp; C)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_dnf</span><span class="p">((</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">B</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">B</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">B</span> <span class="o">&amp;</span> <span class="n">C</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">B</span> <span class="o">&amp;</span> <span class="n">C</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>
<span class="go">A | C</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.to_nnf">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">to_nnf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplify</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1636-L1657"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.to_nnf" title="Permalink to this definition"></a></dt>
<dd><p>Converts <code class="docutils literal notranslate"><span class="pre">expr</span></code> to Negation Normal Form (NNF).</p>
<p>A logical expression is in NNF if it
contains only And, Or and Not, and Not is applied only to literals.
If <code class="docutils literal notranslate"><span class="pre">simplify</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the result contains no redundant clauses.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Not</span><span class="p">,</span> <span class="n">Equivalent</span><span class="p">,</span> <span class="n">to_nnf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_nnf</span><span class="p">(</span><span class="n">Not</span><span class="p">((</span><span class="o">~</span><span class="n">A</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">B</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">C</span> <span class="o">&amp;</span> <span class="n">D</span><span class="p">)))</span>
<span class="go">(A | B) &amp; (~C | ~D)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_nnf</span><span class="p">(</span><span class="n">Equivalent</span><span class="p">(</span><span class="n">A</span> <span class="o">&gt;&gt;</span> <span class="n">B</span><span class="p">,</span> <span class="n">B</span> <span class="o">&gt;&gt;</span> <span class="n">A</span><span class="p">))</span>
<span class="go">(A | ~B | (A &amp; ~B)) &amp; (B | ~A | (B &amp; ~A))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.is_anf">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">is_anf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1742-L1794"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.is_anf" title="Permalink to this definition"></a></dt>
<dd><p>Checks if <code class="docutils literal notranslate"><span class="pre">expr</span></code>  is in Algebraic Normal Form (ANF).</p>
<p>A logical expression is in ANF if it has the form</p>
<div class="math notranslate nohighlight">
\[1 \oplus a \oplus b \oplus ab \oplus abc\]</div>
<p>i.e. it is purely true, purely false, conjunction of
variables or exclusive disjunction. The exclusive
disjunction can only contain true, variables or
conjunction of variables. No negations are permitted.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">And</span><span class="p">,</span> <span class="n">Not</span><span class="p">,</span> <span class="n">Xor</span><span class="p">,</span> <span class="n">true</span><span class="p">,</span> <span class="n">is_anf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_anf</span><span class="p">(</span><span class="n">true</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_anf</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_anf</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_anf</span><span class="p">(</span><span class="n">Xor</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Not</span><span class="p">(</span><span class="n">B</span><span class="p">)))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.is_cnf">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">is_cnf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1845-L1862"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.is_cnf" title="Permalink to this definition"></a></dt>
<dd><p>Test whether or not an expression is in conjunctive normal form.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">is_cnf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_cnf</span><span class="p">(</span><span class="n">A</span> <span class="o">|</span> <span class="n">B</span> <span class="o">|</span> <span class="n">C</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_cnf</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">B</span> <span class="o">&amp;</span> <span class="n">C</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_cnf</span><span class="p">((</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">B</span><span class="p">)</span> <span class="o">|</span> <span class="n">C</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.is_dnf">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">is_dnf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1865-L1884"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.is_dnf" title="Permalink to this definition"></a></dt>
<dd><p>Test whether or not an expression is in disjunctive normal form.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">is_dnf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_dnf</span><span class="p">(</span><span class="n">A</span> <span class="o">|</span> <span class="n">B</span> <span class="o">|</span> <span class="n">C</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_dnf</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">B</span> <span class="o">&amp;</span> <span class="n">C</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_dnf</span><span class="p">((</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">B</span><span class="p">)</span> <span class="o">|</span> <span class="n">C</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_dnf</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">B</span> <span class="o">|</span> <span class="n">C</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.is_nnf">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">is_nnf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplified</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1797-L1842"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.is_nnf" title="Permalink to this definition"></a></dt>
<dd><p>Checks if <code class="docutils literal notranslate"><span class="pre">expr</span></code> is in Negation Normal Form (NNF).</p>
<p>A logical expression is in NNF if it
contains only And, Or and Not, and Not is applied only to literals.
If <code class="docutils literal notranslate"><span class="pre">simplified</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, checks if result contains no redundant clauses.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Not</span><span class="p">,</span> <span class="n">is_nnf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_nnf</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">B</span> <span class="o">|</span> <span class="o">~</span><span class="n">C</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_nnf</span><span class="p">((</span><span class="n">A</span> <span class="o">|</span> <span class="o">~</span><span class="n">A</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">B</span> <span class="o">|</span> <span class="n">C</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_nnf</span><span class="p">((</span><span class="n">A</span> <span class="o">|</span> <span class="o">~</span><span class="n">A</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">B</span> <span class="o">|</span> <span class="n">C</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_nnf</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="n">B</span><span class="p">)</span> <span class="o">|</span> <span class="n">C</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_nnf</span><span class="p">((</span><span class="n">A</span> <span class="o">&gt;&gt;</span> <span class="n">B</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">B</span> <span class="o">&gt;&gt;</span> <span class="n">A</span><span class="p">))</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="simplification-and-equivalence-testing">
<h2>Simplification and equivalence-testing<a class="headerlink" href="#simplification-and-equivalence-testing" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.simplify_logic">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">simplify_logic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">form</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L2723-L2823"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.simplify_logic" title="Permalink to this definition"></a></dt>
<dd><p>This function simplifies a boolean function to its simplified version
in SOP or POS form. The return type is an Or or And object in SymPy.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>expr</strong> : Boolean expression</p>
<p><strong>form</strong> : string (<code class="docutils literal notranslate"><span class="pre">'cnf'</span></code> or <code class="docutils literal notranslate"><span class="pre">'dnf'</span></code>) or <code class="docutils literal notranslate"><span class="pre">None</span></code> (default).</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">'cnf'</span></code> or <code class="docutils literal notranslate"><span class="pre">'dnf'</span></code>, the simplest expression in the corresponding
normal form is returned; if <code class="docutils literal notranslate"><span class="pre">None</span></code>, the answer is returned
according to the form with fewest args (in CNF by default).</p>
</div></blockquote>
<p><strong>deep</strong> : bool (default <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>Indicates whether to recursively simplify any
non-boolean functions contained within the input.</p>
</div></blockquote>
<p><strong>force</strong> : bool (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p>
<blockquote>
<div><p>As the simplifications require exponential time in the number
of variables, there is by default a limit on expressions with
8 variables. When the expression has more than 8 variables
only symbolical simplification (controlled by <code class="docutils literal notranslate"><span class="pre">deep</span></code>) is
made. By setting <code class="docutils literal notranslate"><span class="pre">force</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code>, this limit is removed. Be
aware that this can lead to very long simplification times.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic</span> <span class="kn">import</span> <span class="n">simplify_logic</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">S</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">y</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">z</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span> <span class="o">~</span><span class="n">x</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">y</span> <span class="o">&amp;</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">simplify_logic</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">~x &amp; ~y</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">(z &amp; ~x &amp; ~y) | (~x &amp; ~y &amp; ~z)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">simplify_logic</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
<span class="go">~x &amp; ~y</span>
</pre></div>
</div>
</dd></dl>

<p>SymPy’s <a class="reference internal" href="simplify/simplify.html#sympy.simplify.simplify.simplify" title="sympy.simplify.simplify.simplify"><code class="xref py py-func docutils literal notranslate"><span class="pre">simplify()</span></code></a> function can also be used to simplify logic expressions to their
simplest forms.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.bool_map">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">bool_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bool1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bool2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L2910-L2992"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.bool_map" title="Permalink to this definition"></a></dt>
<dd><p>Return the simplified version of <em>bool1</em>, and the mapping of variables
that makes the two expressions <em>bool1</em> and <em>bool2</em> represent the same
logical behaviour for some correspondence between the variables
of each.
If more than one mappings of this sort exist, one of them
is returned.</p>
<p>For example, <code class="docutils literal notranslate"><span class="pre">And(x,</span> <span class="pre">y)</span></code> is logically equivalent to <code class="docutils literal notranslate"><span class="pre">And(a,</span> <span class="pre">b)</span></code> for
the mapping <code class="docutils literal notranslate"><span class="pre">{x:</span> <span class="pre">a,</span> <span class="pre">y:</span> <span class="pre">b}</span></code> or <code class="docutils literal notranslate"><span class="pre">{x:</span> <span class="pre">b,</span> <span class="pre">y:</span> <span class="pre">a}</span></code>.
If no such mapping exists, return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">SOPform</span><span class="p">,</span> <span class="n">bool_map</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">Not</span><span class="p">,</span> <span class="n">Xor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">function1</span> <span class="o">=</span> <span class="n">SOPform</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">function2</span> <span class="o">=</span> <span class="n">SOPform</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">],[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_map</span><span class="p">(</span><span class="n">function1</span><span class="p">,</span> <span class="n">function2</span><span class="p">)</span>
<span class="go">(y &amp; ~z, {y: a, z: b})</span>
</pre></div>
</div>
<p>The results are not necessarily unique, but they are canonical. Here,
<code class="docutils literal notranslate"><span class="pre">(w,</span> <span class="pre">z)</span></code> could be <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">d)</span></code> or <code class="docutils literal notranslate"><span class="pre">(d,</span> <span class="pre">a)</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span>  <span class="n">Or</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">w</span><span class="p">),</span> <span class="n">And</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">z</span><span class="p">),</span> <span class="n">And</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq2</span> <span class="o">=</span> <span class="n">Or</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">a</span><span class="p">),</span> <span class="n">And</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">d</span><span class="p">),</span> <span class="n">And</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_map</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">eq2</span><span class="p">)</span>
<span class="go">((x &amp; y) | (w &amp; ~y) | (z &amp; ~y), {w: a, x: b, y: c, z: d})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eq</span> <span class="o">=</span> <span class="n">And</span><span class="p">(</span><span class="n">Xor</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">,</span> <span class="n">And</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_map</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">eq</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="go">(c &amp; d &amp; (a | b) &amp; (~a | ~b), {a: a, b: b, c: d, d: x})</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="manipulating-expressions">
<h2>Manipulating expressions<a class="headerlink" href="#manipulating-expressions" title="Permalink to this headline"></a></h2>
<p>The following functions can be used to manipulate Boolean expressions:</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.distribute_and_over_or">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">distribute_and_over_or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1513-L1527"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.distribute_and_over_or" title="Permalink to this definition"></a></dt>
<dd><p>Given a sentence <code class="docutils literal notranslate"><span class="pre">expr</span></code> consisting of conjunctions and disjunctions
of literals, return an equivalent sentence in CNF.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">distribute_and_over_or</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">Not</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distribute_and_over_or</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">And</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">B</span><span class="p">),</span> <span class="n">Not</span><span class="p">(</span><span class="n">C</span><span class="p">))))</span>
<span class="go">(A | ~B) &amp; (A | ~C)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.distribute_or_over_and">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">distribute_or_over_and</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1530-L1546"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.distribute_or_over_and" title="Permalink to this definition"></a></dt>
<dd><p>Given a sentence <code class="docutils literal notranslate"><span class="pre">expr</span></code> consisting of conjunctions and disjunctions
of literals, return an equivalent sentence in DNF.</p>
<p>Note that the output is NOT simplified.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">distribute_or_over_and</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">Or</span><span class="p">,</span> <span class="n">Not</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distribute_or_over_and</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">B</span><span class="p">),</span> <span class="n">C</span><span class="p">))</span>
<span class="go">(B &amp; C) | (C &amp; ~A)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.distribute_xor_over_and">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">distribute_xor_over_and</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1549-L1565"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.distribute_xor_over_and" title="Permalink to this definition"></a></dt>
<dd><p>Given a sentence <code class="docutils literal notranslate"><span class="pre">expr</span></code> consisting of conjunction and
exclusive disjunctions of literals, return an
equivalent exclusive disjunction.</p>
<p>Note that the output is NOT simplified.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">distribute_xor_over_and</span><span class="p">,</span> <span class="n">And</span><span class="p">,</span> <span class="n">Xor</span><span class="p">,</span> <span class="n">Not</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distribute_xor_over_and</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">Xor</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">A</span><span class="p">),</span> <span class="n">B</span><span class="p">),</span> <span class="n">C</span><span class="p">))</span>
<span class="go">(B &amp; C) ^ (C &amp; ~A)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.eliminate_implications">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">eliminate_implications</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1907-L1928"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.eliminate_implications" title="Permalink to this definition"></a></dt>
<dd><p>Change <code class="docutils literal notranslate"><span class="pre">Implies</span></code> and <code class="docutils literal notranslate"><span class="pre">Equivalent</span></code> into <code class="docutils literal notranslate"><span class="pre">And</span></code>, <code class="docutils literal notranslate"><span class="pre">Or</span></code>, and <code class="docutils literal notranslate"><span class="pre">Not</span></code>.
That is, return an expression that is equivalent to <code class="docutils literal notranslate"><span class="pre">expr</span></code>, but has only
<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">|</span></code>, and <code class="docutils literal notranslate"><span class="pre">~</span></code> as logical
operators.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">Implies</span><span class="p">,</span> <span class="n">Equivalent</span><span class="p">,</span>          <span class="n">eliminate_implications</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eliminate_implications</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>
<span class="go">B | ~A</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eliminate_implications</span><span class="p">(</span><span class="n">Equivalent</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>
<span class="go">(A | ~B) &amp; (B | ~A)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eliminate_implications</span><span class="p">(</span><span class="n">Equivalent</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
<span class="go">(A | ~C) &amp; (B | ~A) &amp; (C | ~B)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="truth-tables-and-related-functions">
<h2>Truth tables and related functions<a class="headerlink" href="#truth-tables-and-related-functions" title="Permalink to this headline"></a></h2>
<p>It is possible to create a truth table for a Boolean function with</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.truth_table">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">truth_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L2018-L2083"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.truth_table" title="Permalink to this definition"></a></dt>
<dd><p>Return a generator of all possible configurations of the input variables,
and the result of the boolean expression for those values.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>expr</strong> : Boolean expression</p>
<p><strong>variables</strong> : list of variables</p>
<p><strong>input</strong> : bool (default <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p>
<blockquote>
<div><p>Indicates whether to return the input combinations.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">truth_table</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">truth_table</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> -&gt; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">))</span>
<span class="go">[0, 0] -&gt; True</span>
<span class="go">[0, 1] -&gt; True</span>
<span class="go">[1, 0] -&gt; False</span>
<span class="go">[1, 1] -&gt; True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">truth_table</span><span class="p">(</span><span class="n">x</span> <span class="o">|</span> <span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
<span class="go">[([0, 0], False), ([0, 1], True), ([1, 0], True), ([1, 1], True)]</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">input</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">truth_table</span></code> returns only a list of truth values.
In this case, the corresponding input values of variables can be
deduced from the index of a given output.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">ibin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">truth_table</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span>
<span class="go">[True, False, True, True]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> -&gt; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
<span class="gp">... </span>    <span class="nb">vars</span><span class="p">,</span> <span class="n">ibin</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">vars</span><span class="p">)))),</span> <span class="n">value</span><span class="p">))</span>
<span class="go">[(y, 0), (x, 0)] -&gt; True</span>
<span class="go">[(y, 0), (x, 1)] -&gt; False</span>
<span class="go">[(y, 1), (x, 0)] -&gt; True</span>
<span class="go">[(y, 1), (x, 1)] -&gt; True</span>
</pre></div>
</div>
</dd></dl>

<p>For mapping between integer representations of truth table positions, lists of
zeros and ones and symbols, the following functions can be used:</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.integer_to_term">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">integer_to_term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">str</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/utilities/iterables.py#L330-L399"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.integer_to_term" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of length <code class="docutils literal notranslate"><span class="pre">bits</span></code> corresponding to the binary value
of <code class="docutils literal notranslate"><span class="pre">n</span></code> with small bits to the right (last). If bits is omitted, the
length will be the number required to represent <code class="docutils literal notranslate"><span class="pre">n</span></code>. If the bits are
desired in reversed order, use the <code class="docutils literal notranslate"><span class="pre">[::-1]</span></code> slice of the returned list.</p>
<p>If a sequence of all bits-length lists starting from <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0,...,</span> <span class="pre">0]</span></code>
through <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">1,</span> <span class="pre">...,</span> <span class="pre">1]</span></code> are desired, pass a non-integer for bits, e.g.
<code class="docutils literal notranslate"><span class="pre">'all'</span></code>.</p>
<p>If the bit <em>string</em> is desired pass <code class="docutils literal notranslate"><span class="pre">str=True</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.utilities.iterables</span> <span class="kn">import</span> <span class="n">ibin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ibin</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[1, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ibin</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">[0, 0, 1, 0]</span>
</pre></div>
</div>
<p>If all lists corresponding to 0 to 2**n - 1, pass a non-integer
for bits:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bits</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ibin</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="go">(0, 0)</span>
<span class="go">(0, 1)</span>
<span class="go">(1, 0)</span>
<span class="go">(1, 1)</span>
</pre></div>
</div>
<p>If a bit string is desired of a given length, use str=True:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">123</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bits</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ibin</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="nb">str</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&#39;0001111011&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ibin</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="nb">str</span><span class="o">=</span><span class="kc">True</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># small bits left</span>
<span class="go">&#39;1101111000&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">ibin</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[&#39;000&#39;, &#39;001&#39;, &#39;010&#39;, &#39;011&#39;, &#39;100&#39;, &#39;101&#39;, &#39;110&#39;, &#39;111&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.term_to_integer">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">term_to_integer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">term</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1992-L2012"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.term_to_integer" title="Permalink to this definition"></a></dt>
<dd><p>Return an integer corresponding to the base-2 digits given by <code class="docutils literal notranslate"><span class="pre">term</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>term</strong> : a string or list of ones and zeros</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">term_to_integer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">term_to_integer</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">term_to_integer</span><span class="p">(</span><span class="s1">&#39;100&#39;</span><span class="p">)</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.bool_maxterm">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">bool_maxterm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L2634-L2667"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.bool_maxterm" title="Permalink to this definition"></a></dt>
<dd><p>Return the k-th maxterm.</p>
<p>Each maxterm is assigned an index based on the opposite
conventional binary encoding used for minterms. The maxterm
convention assigns the value 0 to the direct form and 1 to
the complemented form.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>k</strong> : int or list of 1’s and 0’s (complementation pattern)</p>
<p><strong>variables</strong> : list of variables</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">bool_maxterm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_maxterm</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">y | ~x | ~z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_maxterm</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">z | ~x | ~y</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r553"><span class="brackets"><a class="fn-backref" href="#id4">R553</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_maxterms">https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_maxterms</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.bool_minterm">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">bool_minterm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L2598-L2631"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.bool_minterm" title="Permalink to this definition"></a></dt>
<dd><p>Return the k-th minterm.</p>
<p>Minterms are numbered by a binary encoding of the complementation
pattern of the variables. This convention assigns the value 1 to
the direct form and 0 to the complemented form.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>k</strong> : int or list of 1’s and 0’s (complementation patter)</p>
<p><strong>variables</strong> : list of variables</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">bool_minterm</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_minterm</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">x &amp; z &amp; ~y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_minterm</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">x &amp; y &amp; ~z</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r554"><span class="brackets"><a class="fn-backref" href="#id5">R554</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_minterms">https://en.wikipedia.org/wiki/Canonical_normal_form#Indexing_minterms</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.bool_monomial">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">bool_monomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L2670-L2708"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.bool_monomial" title="Permalink to this definition"></a></dt>
<dd><p>Return the k-th monomial.</p>
<p>Monomials are numbered by a binary encoding of the presence and
absences of the variables. This convention assigns the value
1 to the presence of variable and 0 to the absence of variable.</p>
<p>Each boolean function can be uniquely represented by a
Zhegalkin Polynomial (Algebraic Normal Form). The Zhegalkin
Polynomial of the boolean function with <span class="math notranslate nohighlight">\(n\)</span> variables can contain
up to <span class="math notranslate nohighlight">\(2^n\)</span> monomials. We can enumarate all the monomials.
Each monomial is fully specified by the presence or absence
of each variable.</p>
<p>For example, boolean function with four variables <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d)</span></code>
can contain up to <span class="math notranslate nohighlight">\(2^4 = 16\)</span> monomials. The 13-th monomial is the
product <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;</span> <span class="pre">b</span> <span class="pre">&amp;</span> <span class="pre">d</span></code>, because 13 in binary is 1, 1, 0, 1.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>k</strong> : int or list of 1’s and 0’s</p>
<p><strong>variables</strong> : list of variables</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">bool_monomial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_monomial</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">x &amp; z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_monomial</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
<span class="go">x &amp; y</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.anf_coeffs">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">anf_coeffs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">truthvalues</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L2543-L2595"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.anf_coeffs" title="Permalink to this definition"></a></dt>
<dd><p>Convert a list of truth values of some boolean expression
to the list of coefficients of the polynomial mod 2 (exclusive
disjunction) representing the boolean expression in ANF
(i.e., the “Zhegalkin polynomial”).</p>
<p>There are <span class="math notranslate nohighlight">\(2^n\)</span> possible Zhegalkin monomials in <span class="math notranslate nohighlight">\(n\)</span> variables, since
each monomial is fully specified by the presence or absence of
each variable.</p>
<p>We can enumerate all the monomials. For example, boolean
function with four variables <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">c,</span> <span class="pre">d)</span></code> can contain
up to <span class="math notranslate nohighlight">\(2^4 = 16\)</span> monomials. The 13-th monomial is the
product <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;</span> <span class="pre">b</span> <span class="pre">&amp;</span> <span class="pre">d</span></code>, because 13 in binary is 1, 1, 0, 1.</p>
<p>A given monomial’s presence or absence in a polynomial corresponds
to that monomial’s coefficient being 1 or 0 respectively.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">anf_coeffs</span><span class="p">,</span> <span class="n">bool_monomial</span><span class="p">,</span> <span class="n">Xor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">truthvalues</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coeffs</span> <span class="o">=</span> <span class="n">anf_coeffs</span><span class="p">(</span><span class="n">truthvalues</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coeffs</span>
<span class="go">[0, 1, 1, 0, 0, 0, 1, 0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polynomial</span> <span class="o">=</span> <span class="n">Xor</span><span class="p">(</span><span class="o">*</span><span class="p">[</span>
<span class="gp">... </span>    <span class="n">bool_monomial</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span> <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">1</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">polynomial</span>
<span class="go">b ^ c ^ (a &amp; b)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.boolalg.to_int_repr">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.boolalg.</span></span><span class="sig-name descname"><span class="pre">to_int_repr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clauses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbols</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/boolalg.py#L1965-L1989"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.boolalg.to_int_repr" title="Permalink to this definition"></a></dt>
<dd><p>Takes clauses in CNF format and puts them into an integer representation.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.boolalg</span> <span class="kn">import</span> <span class="n">to_int_repr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_int_repr</span><span class="p">([</span><span class="n">x</span> <span class="o">|</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span> <span class="o">==</span> <span class="p">[{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">}]</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-sympy.logic.inference">
<span id="inference"></span><h2>Inference<a class="headerlink" href="#module-sympy.logic.inference" title="Permalink to this headline"></a></h2>
<p>This module implements some inference routines in propositional logic.</p>
<p>The function satisfiable will test that a given Boolean expression is satisfiable,
that is, you can assign values to the variables to make the sentence <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>For example, the expression <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&amp;</span> <span class="pre">~x</span></code> is not satisfiable, since there are no
values for <code class="docutils literal notranslate"><span class="pre">x</span></code> that make this sentence <code class="docutils literal notranslate"><span class="pre">True</span></code>. On the other hand, <code class="docutils literal notranslate"><span class="pre">(x</span>
<span class="pre">|</span> <span class="pre">y)</span> <span class="pre">&amp;</span> <span class="pre">(x</span> <span class="pre">|</span> <span class="pre">~y)</span> <span class="pre">&amp;</span> <span class="pre">(~x</span> <span class="pre">|</span> <span class="pre">y)</span></code> is satisfiable with both <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> being
<code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.inference</span> <span class="kn">import</span> <span class="n">satisfiable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">satisfiable</span><span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">x</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">satisfiable</span><span class="p">((</span><span class="n">x</span> <span class="o">|</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">|</span> <span class="o">~</span><span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">|</span> <span class="n">y</span><span class="p">))</span>
<span class="go">{x: True, y: True}</span>
</pre></div>
</div>
<p>As you see, when a sentence is satisfiable, it returns a model that makes that
sentence <code class="docutils literal notranslate"><span class="pre">True</span></code>. If it is not satisfiable it will return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<dl class="py function">
<dt class="sig sig-object py" id="sympy.logic.inference.satisfiable">
<span class="sig-prename descclassname"><span class="pre">sympy.logic.inference.</span></span><span class="sig-name descname"><span class="pre">satisfiable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_models</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/logic/inference.py#L38-L108"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sympy.logic.inference.satisfiable" title="Permalink to this definition"></a></dt>
<dd><p>Check satisfiability of a propositional sentence.
Returns a model when it succeeds.
Returns {true: true} for trivially true expressions.</p>
<p>On setting all_models to True, if given expr is satisfiable then
returns a generator of models. However, if expr is unsatisfiable
then returns a generator containing the single element False.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.logic.inference</span> <span class="kn">import</span> <span class="n">satisfiable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">satisfiable</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">B</span><span class="p">)</span>
<span class="go">{A: True, B: False}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">satisfiable</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">A</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">satisfiable</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{True: True}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">satisfiable</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">A</span><span class="p">,</span> <span class="n">all_models</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">models</span> <span class="o">=</span> <span class="n">satisfiable</span><span class="p">((</span><span class="n">A</span> <span class="o">&gt;&gt;</span> <span class="n">B</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">B</span><span class="p">,</span> <span class="n">all_models</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">models</span><span class="p">)</span>
<span class="go">{A: False, B: True}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">models</span><span class="p">)</span>
<span class="go">{A: True, B: True}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">use_models</span><span class="p">(</span><span class="n">models</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">model</span><span class="p">:</span>
<span class="gp">... </span>            <span class="c1"># Do something with the model.</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>            <span class="c1"># Given expr is unsatisfiable.</span>
<span class="gp">... </span>            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;UNSAT&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">use_models</span><span class="p">(</span><span class="n">satisfiable</span><span class="p">(</span><span class="n">A</span> <span class="o">&gt;&gt;</span> <span class="o">~</span><span class="n">A</span><span class="p">,</span> <span class="n">all_models</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">{A: False}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">use_models</span><span class="p">(</span><span class="n">satisfiable</span><span class="p">(</span><span class="n">A</span> <span class="o">^</span> <span class="n">A</span><span class="p">,</span> <span class="n">all_models</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">UNSAT</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../reference/public/logic/index.html" class="btn btn-neutral float-left" title="Logic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="sets.html" class="btn btn-neutral float-right" title="Sets" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022 SymPy Development Team.
      <span class="lastupdated">Last updated on Jan 14, 2022.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>