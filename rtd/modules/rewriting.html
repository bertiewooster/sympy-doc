<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Term Rewriting &mdash; SymPy 1.10.dev documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../_static/plot_directive.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/sympy-notailtext-favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script src="../_static/js/theme.js"></script>
    <link href="https://docs.sympy.org/latest/modules/rewriting.html" rel="canonical" />
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Code Generation" href="../reference/public/codegeneration/index.html" />
    <link rel="prev" title="Numeric Computation" href="numeric-computation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> SymPy
            <img src="../_static/sympylogo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                1.10.dev
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../tutorial/index.html">SymPy Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guides/index.html">SymPy Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../explanation/index.html">Explanation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../reference/index.html">Reference Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../reference/index.html#basics"><span class="xref std std-ref">Basics</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/index.html#code-generation"><span class="xref std std-ref">Code Generation</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/index.html#logic"><span class="xref std std-ref">Logic</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/index.html#matrices"><span class="xref std std-ref">Matrices</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/index.html#number-theory"><span class="xref std std-ref">Number Theory</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/index.html#physics"><span class="xref std std-ref">Physics</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="../reference/index.html#utilities"><span class="xref std std-ref">Utilities</span></a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../reference/index.html#topics"><span class="xref std std-ref">Topics</span></a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../reference/public/basics/index.html">Basics</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="assumptions/index.html">Assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="calculus/index.html">Calculus</a></li>
<li class="toctree-l4"><a class="reference internal" href="combinatorics/index.html">Combinatorics</a></li>
<li class="toctree-l4"><a class="reference internal" href="functions/index.html">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="integrals/index.html">Integrals</a></li>
<li class="toctree-l4"><a class="reference internal" href="series/index.html">Series</a></li>
<li class="toctree-l4"><a class="reference internal" href="simplify/index.html">Simplify</a></li>
<li class="toctree-l4"><a class="reference internal" href="solvers/index.html">Solvers</a></li>
<li class="toctree-l4"><a class="reference internal" href="abc.html">abc</a></li>
<li class="toctree-l4"><a class="reference internal" href="algebras.html">Algebras</a></li>
<li class="toctree-l4"><a class="reference internal" href="concrete.html">Concrete</a></li>
<li class="toctree-l4"><a class="reference internal" href="core.html">Core</a></li>
<li class="toctree-l4"><a class="reference internal" href="discrete.html">Discrete</a></li>
<li class="toctree-l4"><a class="reference internal" href="evalf.html">Numerical Evaluation</a></li>
<li class="toctree-l4"><a class="reference internal" href="numeric-computation.html">Numeric Computation</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Term Rewriting</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../reference/public/codegeneration/index.html">Code Generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/public/logic/index.html">Logic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/public/matrices/index.html">Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/public/numbertheory/index.html">Number Theory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/public/physics/index.html">Physics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/public/utilities/index.html">Utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../reference/public/topics/index.html">Topics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../miscellaneous/index.html">Miscellaneous</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SymPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../reference/index.html">Reference Documentation</a> &raquo;</li>
          <li><a href="../reference/public/basics/index.html">Basics</a> &raquo;</li>
      <li>Term Rewriting</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/modules/rewriting.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="term-rewriting">
<h1>Term Rewriting<a class="headerlink" href="#term-rewriting" title="Permalink to this headline"></a></h1>
<p>Term rewriting is a very general class of functionalities which are used to
convert expressions of one type in terms of expressions of different kind. For
example expanding, combining and converting expressions apply to term
rewriting, and also simplification routines can be included here. Currently
SymPy has several functions and basic built-in methods for performing various
types of rewriting.</p>
<section id="expanding">
<h2>Expanding<a class="headerlink" href="#expanding" title="Permalink to this headline"></a></h2>
<p>The simplest rewrite rule is expanding expressions into a _sparse_ form.
Expanding has several flavors and include expanding complex valued expressions,
arithmetic expand of products and powers but also expanding functions in terms
of more general functions is possible. Below are listed all currently available
expand rules.</p>
<dl>
<dt>Expanding of arithmetic expressions involving products and powers:</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;x,y,z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">basic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**2 - y**2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">basic</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">x**2 + 2*x*y + 2*x*z + y**2 + 2*y*z + z**2</span>
</pre></div>
</div>
</dd>
</dl>
<p>Arithmetic expand is done by default in <code class="docutils literal notranslate"><span class="pre">expand()</span></code> so the keyword <code class="docutils literal notranslate"><span class="pre">basic</span></code> can
be omitted. However you can set <code class="docutils literal notranslate"><span class="pre">basic=False</span></code> to avoid this type of expand if
you use rules described below. This give complete control on what is done with
the expression.</p>
<p>Another type of expand rule is expanding complex valued expressions and putting
them into a normal form. For this <code class="docutils literal notranslate"><span class="pre">complex</span></code> keyword is used. Note that it will
always perform arithmetic expand to obtain the desired normal form:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="nb">complex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">re(x) + I*re(y) + I*im(x) - im(y)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="nb">complex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">sin(re(x) - im(y))*cosh(re(y) + im(x)) + I*cos(re(x) - im(y))*sinh(re(y) + im(x))</span>
</pre></div>
</div>
<p>Note also that the same behavior can be obtained by using <code class="docutils literal notranslate"><span class="pre">as_real_imag()</span></code>
method. However it will return a tuple containing the real part in the first
place and the imaginary part in the other. This can be also done in a two step
process by using <code class="docutils literal notranslate"><span class="pre">collect</span></code> function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">as_real_imag</span><span class="p">()</span>
<span class="go">(re(x) - im(y), re(y) + im(x))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">collect</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">I</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="nb">complex</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">I</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">{1: re(x) - im(y), I: re(y) + im(x)}</span>
</pre></div>
</div>
<p>There is also possibility for expanding expressions in terms of expressions of
different kind. This is very general type of expanding and usually you would
use <code class="docutils literal notranslate"><span class="pre">rewrite()</span></code> to do specific type of rewrite:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">GoldenRatio</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">1/2 + sqrt(5)/2</span>
</pre></div>
</div>
</section>
<section id="common-subexpression-detection-and-collection">
<h2>Common Subexpression Detection and Collection<a class="headerlink" href="#common-subexpression-detection-and-collection" title="Permalink to this headline"></a></h2>
<p>Before evaluating a large expression, it is often useful to identify common
subexpressions, collect them and evaluate them at once. This is implemented
in the <code class="docutils literal notranslate"><span class="pre">cse</span></code> function. Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">cse</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">cse</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">⎛    ⎡  ________⎤⎞</span>
<span class="go">⎝[], ⎣╲╱ sin(x) ⎦⎠</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">cse</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="mi">4</span><span class="p">)),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">⎛                ⎡  ________   ________⎤⎞</span>
<span class="go">⎝[(x₀, sin(x))], ⎣╲╱ x₀ + 4 ⋅╲╱ x₀ + 5 ⎦⎠</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">cse</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">y</span><span class="p">))),</span>
<span class="gp">... </span>    <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">⎛                             ⎡  ________   ________⎤⎞</span>
<span class="go">⎝[(x₀, sin(x + 1) + cos(y))], ⎣╲╱ x₀ + 4 ⋅╲╱ x₀ + 5 ⎦⎠</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">cse</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">y</span><span class="p">))),</span> <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">⎛                          ⎡  ____     ⎤⎞</span>
<span class="go">⎝[(x₀, (x - y)⋅(-y + z))], ⎣╲╱ x₀  + x₀⎦⎠</span>
</pre></div>
</div>
<p>Optimizations to be performed before and after common subexpressions
elimination can be passed in the``optimizations`` optional argument. A set of
predefined basic optimizations can be applied by passing
<code class="docutils literal notranslate"><span class="pre">optimizations='basic'</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="p">(</span><span class="n">cse</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">y</span><span class="p">)),</span> <span class="n">optimizations</span><span class="o">=</span><span class="s1">&#39;basic&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">use_unicode</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">⎛                          ⎡  ____     ⎤⎞</span>
<span class="go">⎝[(x₀, -(x - y)⋅(y - z))], ⎣╲╱ x₀  + x₀⎦⎠</span>
</pre></div>
</div>
<p>However, these optimizations can be very slow for large expressions. Moreover,
if speed is a concern, one can pass the option <code class="docutils literal notranslate"><span class="pre">order='none'</span></code>. Order of
terms will then be dependent on hashing algorithm implementation, but speed
will be greatly improved.</p>
<p>More information:</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">sympy.simplify.cse_main.</span></span><span class="sig-name descname"><span class="pre">cse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exprs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">postprocess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'canonical'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/sympy/sympy/blob/0b23b452402f1f796b08ecae4261e3850c55991e/sympy/simplify/cse_main.py#L695-L849"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Perform common subexpression elimination on an expression.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>exprs</strong> : list of SymPy expressions, or a single SymPy expression</p>
<blockquote>
<div><p>The expressions to reduce.</p>
</div></blockquote>
<p><strong>symbols</strong> : infinite iterator yielding unique Symbols</p>
<blockquote>
<div><p>The symbols used to label the common subexpressions which are pulled
out. The <code class="docutils literal notranslate"><span class="pre">numbered_symbols</span></code> generator is useful. The default is a
stream of symbols of the form “x0”, “x1”, etc. This must be an
infinite iterator.</p>
</div></blockquote>
<p><strong>optimizations</strong> : list of (callable, callable) pairs</p>
<blockquote>
<div><p>The (preprocessor, postprocessor) pairs of external optimization
functions. Optionally ‘basic’ can be passed for a set of predefined
basic optimizations. Such ‘basic’ optimizations were used by default
in old implementation, however they can be really slow on larger
expressions. Now, no pre or post optimizations are made by default.</p>
</div></blockquote>
<p><strong>postprocess</strong> : a function which accepts the two return values of cse and</p>
<blockquote>
<div><p>returns the desired form of output from cse, e.g. if you want the
replacements reversed the function might be the following lambda:
lambda r, e: return reversed(r), e</p>
</div></blockquote>
<p><strong>order</strong> : string, ‘none’ or ‘canonical’</p>
<blockquote>
<div><p>The order by which Mul and Add arguments are processed. If set to
‘canonical’, arguments will be canonically ordered. If set to ‘none’,
ordering will be faster but dependent on expressions hashes, thus
machine dependent and variable. For large expressions where speed is a
concern, use the setting order=’none’.</p>
</div></blockquote>
<p><strong>ignore</strong> : iterable of Symbols</p>
<blockquote>
<div><p>Substitutions containing any Symbol from <code class="docutils literal notranslate"><span class="pre">ignore</span></code> will be ignored.</p>
</div></blockquote>
<p><strong>list</strong> : bool, (default True)</p>
<blockquote>
<div><p>Returns expression in list or else with same type as input (when False).</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>replacements</strong> : list of (Symbol, expression) pairs</p>
<blockquote>
<div><p>All of the common subexpressions that were replaced. Subexpressions
earlier in this list might show up in subexpressions later in this
list.</p>
</div></blockquote>
<p><strong>reduced_exprs</strong> : list of SymPy expressions</p>
<blockquote>
<div><p>The reduced expressions with all of the replacements above.</p>
</div></blockquote>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">cse</span><span class="p">,</span> <span class="n">SparseMatrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.abc</span> <span class="kn">import</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cse</span><span class="p">(((</span><span class="n">w</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="go">([(x0, y + z), (x1, w + x)], [(w + x0)*(x0 + x1)/x1**3])</span>
</pre></div>
</div>
<p>List of expressions with recursive substitutions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">SparseMatrix</span><span class="p">([</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cse</span><span class="p">([(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">m</span><span class="p">])</span>
<span class="go">([(x0, x + y), (x1, x0 + z)], [x0**2, x1, y + z, x1, Matrix([</span>
<span class="go">[x0],</span>
<span class="go">[x1]])])</span>
</pre></div>
</div>
<p>Note: the type and mutability of input matrices is retained.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">SparseMatrix</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The user may disallow substitutions containing certain symbols:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cse</span><span class="p">([</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">ignore</span><span class="o">=</span><span class="p">(</span><span class="n">y</span><span class="p">,))</span>
<span class="go">([(x0, x + 1)], [x0*y**2, 3*x0*y**2])</span>
</pre></div>
</div>
<p>The default return value for the reduced expression(s) is a list, even if there is only
one expression. The <span class="math notranslate nohighlight">\(list\)</span> flag preserves the type of the input in the output:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">([], [x])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">([], x)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="numeric-computation.html" class="btn btn-neutral float-left" title="Numeric Computation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../reference/public/codegeneration/index.html" class="btn btn-neutral float-right" title="Code Generation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022 SymPy Development Team.
      <span class="lastupdated">Last updated on Jan 14, 2022.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>